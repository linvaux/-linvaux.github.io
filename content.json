{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://linvaux.github.io","root":"/"},"pages":[{"title":"categories","date":"2024-07-25T14:43:59.000Z","updated":"2024-07-25T14:43:59.465Z","comments":true,"path":"categories/index.html","permalink":"https://linvaux.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2024-07-25T14:43:48.000Z","updated":"2024-07-25T14:43:48.484Z","comments":true,"path":"tags/index.html","permalink":"https://linvaux.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"IDEA插件整理(一)","slug":"IDEA插件整理（一）","date":"2024-07-25T15:24:54.000Z","updated":"2024-07-25T15:38:47.895Z","comments":true,"path":"2024/07/25/IDEA插件整理（一）/","permalink":"https://linvaux.github.io/2024/07/25/IDEA%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"Atom Material Icons material风格图标库，装完之后页面就花里胡哨的，挺好看 Material Theme UI material风格主题，还是挺好看的 One Dark Theme 暗黑风格主题（推荐），主要是免费 Rainbow Brackets 彩虹括号 .ignore 生成各类.ignore文件，在创建git仓库的时候使用此插件格外方便 CodeGlance 代码缩略图，方便定位代码 Java Bean to Json 在bean上右键，即可将此bean复制为json格式，在构造请求时比较方便 maven-search maven&#x2F;gradle坐标搜索插件，贼好用，支持模糊搜索 Maven Helper 依赖冲突查看神器，也可以树状展示依赖关系 Mybatisx mybatis-plus团队出品的插件，支持从数据库表直接生成代码，包含基本CRUD功能，很方便 MyBatisCodeHelperPro 怎么说呢，就是很厉害，基本不用自己写代码了，但是收费 演示视频：https://www.bilibili.com/video/av50632948 使用文档：https://gejun123456.github.io/MyBatisCodeHelper-Pro/#/ MyBatis Log EasyPlus 格式化mybatis日志，很好用 SequenceDiagram 生成方法的时序图，非常有用官方文档：https://vanco.github.io/SequencePlugin/ PlantUML 时序图，类图绘制插件 Grep Console 由于Intellij idea不支持显示ascii颜色，grep-console插件能很好的解决这个问题，下面就以开发JavaEE项目中，结合Log4j配置多颜色日志输出功能。 GitToolBox git工具箱，可以显示当前代码分支和每一行代码提交人以及commit log Translation 翻译插件，再也不用去百度翻译了 RestfulToolkit 根据url直接跳转到对应的controller，比较好用，尤其是url多的时候，直接搜索url就可以了 Key promoter X 记性不好的可以试试，时间长了就能记住快捷键了 Statistic 项目信息统计 Git Commit Message Helper 帮助生成commit message","categories":[{"name":"工具分享","slug":"工具分享","permalink":"https://linvaux.github.io/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Java, IDEA","slug":"Java-IDEA","permalink":"https://linvaux.github.io/tags/Java-IDEA/"}]},{"title":"EasyExcel自定义字段导入","slug":"EasyExcel自定义字段导入","date":"2024-07-25T15:10:00.000Z","updated":"2024-07-25T15:10:32.847Z","comments":true,"path":"2024/07/25/EasyExcel自定义字段导入/","permalink":"https://linvaux.github.io/2024/07/25/EasyExcel%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E6%AE%B5%E5%AF%BC%E5%85%A5/","excerpt":"","text":"1.背景原先的导入功能只支持使用固定模板导入，模板格式如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Getter@Setter@ToStringpublic class TestCaseExcelData &#123; @ExcelProperty(value = &quot;所属功能模块&quot;) private String module; @ExcelProperty(value = &quot;用例编号&quot;) private String code; @NotBlank(message = &quot;必填项不能为空&quot;) @ExcelProperty(value = &quot;*用例名称&quot;) private String name; @NotBlank(message = &quot;必填项不能为空&quot;) @ExcelProperty(value = &quot;*优先级&quot;) private String caseLevel; @NotBlank(message = &quot;必填项不能为空&quot;) @ExcelProperty(value = &quot;*用例类型&quot;) private String caseType; @ExcelProperty(value = &quot;用例标签&quot;) private String tags; @ExcelProperty(value = &quot;前置条件&quot;) private String preSteps; @NotBlank(message = &quot;必填项不能为空&quot;) @ExcelProperty(value = &quot;*操作步骤/场景描述&quot;) private String stepDesc; @NotBlank(message = &quot;必填项不能为空&quot;) @ExcelProperty(value = &quot;*预期结果&quot;) private String expectResult; @ExcelProperty(value = &quot;关联需求类型&quot;) private String requirementType; @ExcelProperty(value = &quot;关联需求ID&quot;) private String requirementId; @ExcelProperty(value = &quot;用例版本&quot;) private String caseVersion;&#125; EasyExcel 导入监听器直接使用AnalysisEventListener 即可实现导入校验，校验规则较为复杂，不在此处展开。现在要求用户配置了自定义字段之后，还可以导入自定义字段，同时保留对固定字段的校验逻辑。因此原有的适用对象的监听器不再适用，需要使用无对象的方式做数据校验。 2.问题 EasyExcel 无对象方式的监听器是继承AnalysisEventListener&lt;Map&lt;Integer, String&gt;&gt;类，在重写了invoke() 方法后发现，入参是 Map&lt;Integer, String&gt; data，这就导致我无法对每一行数据按照原有的方式校验。 用户导入的模板列顺序是不固定的，因此也没法遍历 data 进行原有规则的校验。 3.解决方案3.1 解决思路 既然 invoke() 方法入参是 Map&lt;Integer, String&gt; data 这种数据结构，那能不能把这个 Map 中固定的字段转为一个 TestCaseExcelData 对象来处理？ 如果要转为一个对象，那怎么把 Map 中的数据跟对象的字段做映射？ 3.2 Map 转对象 Map&lt;Integer, String&gt; 是当前行的数据，其中 key 是当前行的列索引，value 是当前单元格的值，如果要转对象，首先得知道这个单元格对应的表头是什么，获取表头的方式很简单，直接在 listener 中定义一个 Map&lt;Integer, String&gt; headMap ,然后重写 invokeHeadMap(Map&lt;Integer, String&gt; headMap, AnalysisContext context) 方法，即可获取到表头。 取到表头之后，就可以在 invoke(Map&lt;Integer, String&gt; data, AnalysisContext context)方法中遍历data，根据此 map 的 key 来获取到当前单元格表头信息。代码如下：1234567@Overridepublic void invoke(Map&lt;Integer, String&gt; data, AnalysisContext context) &#123; data.forEach((index, value) -&gt; &#123; // 获取表头 String headName = headMap.get(index); &#125;); &#125; 取到了当前单元格的对应的表头之后，发现这个表头就是 TestCaseExcelData 类中属性上加的 @ExcelProperty(value &#x3D; “用例版本”) 注解中 value 属性的值，那就简单了，直接通过反射获取这个类所有表头和对应的属性，然后存到一个 Map&lt;Stirng, Field&gt; fieldStringMap 中就好了，这样就能通过表头获取到这个表头字段对应的类属性，为我们后面创建对象奠定了基础。代码如下：12345678Field[] fields = TestCaseExcelData.class.getDeclaredFields();for (Field field : fields) &#123; if (field.isAnnotationPresent(ExcelProperty.class)) &#123; ExcelProperty declaredAnnotation = field.getDeclaredAnnotation(ExcelProperty.class); String headValue = declaredAnnotation.value()[0]; this.fieldStringMap.put(headValue, field); &#125;&#125; 经过上面的几步操作，我们已经得到了如下的几个Map123456// 当前行的数据 &lt;列索引, 单元格值&gt;Map&lt;Integer, String&gt; data;// 表头的数据 &lt;列索引, 单元格值&gt;Map&lt;Integer, String&gt; headMap;// 实体对象表头和对应字段的数据 &lt;表头名称, 表头对应的属性&gt;Map&lt;Stirng, Field&gt; fieldStringMap; 后面的思路经很清晰了，遍历行数据Map&lt;Integer, String&gt; data ，通过 key 来确定当前单元格对应的表头，然后通过表头来获取实体类对应的属性，再通过反射来给这个属性赋值。代码如下：1234567891011121314151617181920212223242526272829303132@Overridepublic void invoke(Map&lt;Integer, String&gt; data, AnalysisContext context) &#123; // 创建实体对象 TestCaseExcelData rawData = new TestCaseExcelData(); try &#123; data.forEach((index, value) -&gt; &#123; // 获取到当前单元格的表头 String headName = headMap.get(index); // 根据表头获取实体类的属性 Field field = fieldStringMap.get(headName); try &#123; // 判断实体类是否有此属性 if (field != null) &#123; field.setAccessible(true); // 通过反射直接赋值 field.set(rawData, value); &#125; &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; // 解析自定义字段，只有系统配置的字段才会被缓存 List&lt;CustomFieldPO&gt; customFieldPOS = systemCustomFieldMap.get(headName); if (CollectionUtils.isNotEmpty(customFieldPOS)) &#123; customFieldMap.put(customFieldPOS.get(0).getFieldKey(), value); &#125; &#125;); // 固定字段校验 ExcelValidateHelper.validateEntity(rawData); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; &#125; 经过以上操作，我们成功的把一个 Map 转为了一个已知的对象，这样就跟通过对象导入一样了，后面校验的代码也无需再重复编写。 4. 其他最后，附上自定义模板校验表头的代码 12345678910111213141516171819@Overridepublic void invokeHeadMap(Map&lt;Integer, String&gt; headMap, AnalysisContext context) &#123; super.invokeHeadMap(headMap, context); // 限制文件行数不超过5000行 if (context.readSheetHolder().getApproximateTotalRowNumber() &gt; 5000) &#123; throw new ServiceException(CommonException.EXCEL_ROW_EXCEEDED); &#125; // 校验excel模版是否正确 ExcelImportUtil.validateHeadLoosely(headMap, this.dynamicCaseHeader.get(0)); this.headMap = headMap; Field[] fields = TestCaseExcelData.class.getDeclaredFields(); for (Field field : fields) &#123; if (field.isAnnotationPresent(ExcelProperty.class)) &#123; ExcelProperty declaredAnnotation = field.getDeclaredAnnotation(ExcelProperty.class); String headValue = declaredAnnotation.value()[0]; this.fieldStringMap.put(headValue, field); &#125; &#125; &#125; 1234567891011121314151617181920212223242526272829303132/** * 表头宽松校验 * &lt;p&gt;只校验表头是否存在模板中的字段&lt;/p&gt; * &lt;p&gt;不允许存在重复的表头&lt;/p&gt; * &lt;p&gt;导入文件中可以包含多余的列名&lt;/p&gt; * * @param headMap 实际读到的表头 * @param expectedHeadMapFiled 期望的表头 */public static void validateHeadLoosely(Map&lt;Integer, String&gt; headMap, List&lt;String&gt; expectedHeadMapFiled) &#123; try &#123; if (CollectionUtils.isEmpty(expectedHeadMapFiled) || MapUtils.isEmpty(headMap)) &#123; throw new ServiceException(CommonException.EXCEL_TEMPLATE_IS_NOT_CORRECT); &#125; // 移除没有内容的表头 headMap.entrySet().removeIf(entry -&gt; entry.getValue() == null); // 判断是否存在重复列 Collection&lt;String&gt; headValues = headMap.values(); Set&lt;String&gt; headValuesSet = new HashSet&lt;&gt;(headValues); if (headValues.size() != headValuesSet.size()) &#123; throw new ServiceException(CommonException.EXCEL_HEADS_DUPLICATED); &#125; // 判断模板字段是否都包含在表头里 for (String value : expectedHeadMapFiled) &#123; if (!headMap.containsValue(value)) &#123; throw new ServiceException(CommonException.EXCEL_TEMPLATE_IS_NOT_CORRECT); &#125; &#125; &#125; catch (Exception e) &#123; throw new ServiceException(&quot;Excel表头校验失败，异常详情：&quot; + ExceptionUtil.getErrorMessage(e)); &#125; &#125;","categories":[],"tags":[{"name":"Java, EasyExcel","slug":"Java-EasyExcel","permalink":"https://linvaux.github.io/tags/Java-EasyExcel/"}]},{"title":"EasyExcel自定义单元格样式","slug":"EasyExcel自定义单元格样式","date":"2024-07-25T15:09:03.000Z","updated":"2024-07-25T15:11:30.742Z","comments":true,"path":"2024/07/25/EasyExcel自定义单元格样式/","permalink":"https://linvaux.github.io/2024/07/25/EasyExcel%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%95%E5%85%83%E6%A0%BC%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"之前在开发系统的导出功能时需要对单元格增加不同的样式，过程有点曲折，记录一下以备后续用到 创建java项目，引入以下依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt; excel 导出代码 123456789101112131415try (ExcelWriter excelWriter = EasyExcel.write(filePath).build()) &#123; WriteSheet sheet = EasyExcel.writerSheet(&quot;自定义样式&quot;) // 设置表头 .head(ExportHeaderDTO.class) // 不使用默认样式 .useDefaultStyle(Boolean.FALSE) // 添加自定义单元格样式 .registerWriteHandler(new CustomCellWriteHandler()) // 添加单元格边框样式 .registerWriteHandler(CustomHorizontalCellStyleStrategy.cellBorder()) .build(); excelWriter.write(collect, sheet); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 自定义样式 CustomCellWriteHandler.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class CustomCellWriteHandler implements CellWriteHandler &#123; /** * 设置拦截器顺序，需要 &gt; 50000 * * @return 拦截器顺序 */ @Override public int order() &#123; return 60000; &#125; @Override public void afterCellDispose(CellWriteHandlerContext context) &#123; Cell cell = context.getCell(); if (BooleanUtils.isNotTrue(context.getHead())) &#123; Workbook workbook = context.getWriteWorkbookHolder().getWorkbook(); XSSFCellStyle cellStyle = (XSSFCellStyle) workbook.createCellStyle(); cellStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND); // 设置边框粗细 cellStyle.setBorderRight(BorderStyle.THIN); cellStyle.setBorderTop(BorderStyle.THIN); cellStyle.setBorderRight(BorderStyle.THIN); cellStyle.setBorderBottom(BorderStyle.THIN); // 设置边框颜色 cellStyle.setTopBorderColor(IndexedColors.BLACK.index); cellStyle.setBottomBorderColor(IndexedColors.BLACK.index); cellStyle.setLeftBorderColor(IndexedColors.BLACK.index); cellStyle.setRightBorderColor(IndexedColors.BLACK.index); cellStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND); // 水平居中 cellStyle.setAlignment(HorizontalAlignment.CENTER); // 垂直居中 cellStyle.setVerticalAlignment(VerticalAlignment.CENTER); Font font = workbook.createFont(); if (cell.getColumnIndex() == 1) &#123; // 设置字体颜色 font.setColor(IndexedColors.DARK_TEAL.index); cellStyle.setFont(font); // 设置单元格颜色 cellStyle.setFillForegroundColor(new XSSFColor(ColorConstant.CustomColor.PINK, CustomIndexedColorMap.fromColors(CTColors.Factory.newInstance()))); cell.setCellStyle(cellStyle); // 这里要把 WriteCellData的样式清空， 不然后面还有一个拦截器 FillStyleCellWriteHandler 默认会将 WriteCellStyle 设置到cell里面去 会导致自己设置的不一样（很关键） context.getFirstCellData().setWriteCellStyle(null); &#125; &#125; &#125;&#125; 边框样式 CustomHorizontalCellStyleStrategy.java 12345678910111213141516171819202122232425public class CustomHorizontalCellStyleStrategy extends HorizontalCellStyleStrategy &#123; @Override public int order() &#123; return 6500; &#125; /** * 设置单元格边框 * @return 样式策略 */ public static HorizontalCellStyleStrategy cellBorder() &#123; WriteCellStyle headWriteCellStyle = new WriteCellStyle(); headWriteCellStyle.setTopBorderColor(IndexedColors.BLACK.index); headWriteCellStyle.setBottomBorderColor(IndexedColors.BLACK.index); headWriteCellStyle.setLeftBorderColor(IndexedColors.BLACK.index); headWriteCellStyle.setRightBorderColor(IndexedColors.BLACK.index); headWriteCellStyle.setFillPatternType(FillPatternType.SOLID_FOREGROUND); WriteCellStyle contentWriteCellStyle = new WriteCellStyle(); contentWriteCellStyle.setBorderRight(BorderStyle.THIN); contentWriteCellStyle.setBorderTop(BorderStyle.THIN); contentWriteCellStyle.setBorderRight(BorderStyle.THIN); contentWriteCellStyle.setBorderBottom(BorderStyle.THIN); return new HorizontalCellStyleStrategy(headWriteCellStyle, contentWriteCellStyle); &#125;&#125;","categories":[],"tags":[{"name":"Java, EasyExcel","slug":"Java-EasyExcel","permalink":"https://linvaux.github.io/tags/Java-EasyExcel/"}]},{"title":"基于Centos7的UI自动化环境Dockerfile","slug":"基于Centos7的UI自动化环境Dockerfile","date":"2024-07-25T15:08:06.000Z","updated":"2024-07-25T15:08:31.205Z","comments":true,"path":"2024/07/25/基于Centos7的UI自动化环境Dockerfile/","permalink":"https://linvaux.github.io/2024/07/25/%E5%9F%BA%E4%BA%8ECentos7%E7%9A%84UI%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83Dockerfile/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657FROM centos:7MAINTAINER linvaux &lt;linvaux@outlook.com&gt;WORKDIR /opt# 修改源，安装依赖RUN sed -i &quot;s/#baseurl/baseurl/g&quot; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\ sed -i &quot;s/mirrorlist=http/#mirrorlist=http/g&quot; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\ sed -i &quot;s@http://mirror.centos.org@https://repo.huaweicloud.com@g&quot; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\ yum clean all &amp;&amp; \\ yum makecache &amp;&amp; \\ yum update -y &amp;&amp; \\ yum install -y wget git zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc make# 安装JDK1.8RUN wget http://10.177.248.111:8089/ftp/dev_tools/jdk-8u271-linux-x64.tar.gz &amp;&amp; \\ tar -vxf jdk-8u271-linux-x64.tar.gz &amp;&amp; \\ mv jdk1.8.0_271/ /usr/local/ &amp;&amp; \\ echo &#x27;export JAVA_HOME=/usr/local/jdk1.8.0_271&#x27; &gt;&gt; /etc/profile &amp;&amp; \\ echo &#x27;export JRE_HOME=$&#123;JAVA_HOME&#125;/jre&#x27; &gt;&gt; /etc/profile &amp;&amp; \\ echo &#x27;export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib&#x27; &gt;&gt; /etc/profile &amp;&amp; \\ echo &#x27;export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH&#x27; &gt;&gt; /etc/profile echo `java -version`# 安装python3.7RUN wget https://mirrors.huaweicloud.com/python/3.7.8/Python-3.7.8.tgz &amp;&amp; \\ tar -vxf Python-3.7.8.tgz &amp;&amp; \\ mv Python-3.7.8 /usr/local/python378 &amp;&amp; \\ cd /usr/local/python378 &amp;&amp; \\ ./configure --prefix=/usr/local/python378 --enable-loadable-sqlite-extensions --with-ssl &amp;&amp;\\ make -j$(nproc) &amp;&amp; \\ make install -j$(nproc) &amp;&amp; \\ ln -s /usr/local/python378/bin/python3.7 /usr/bin/python3 &amp;&amp; \\ ln -s /usr/local/python378/bin/pip3 /usr/bin/pip3 &amp;&amp; \\ mkdir /root/.pip &amp;&amp; \\ echo &quot;[global]&quot; &gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;index-url=https://pypi.douban.com/simple/&quot; &gt;&gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;[install]&quot; &gt;&gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;trusted-host=pypi.douban.com&quot; &gt;&gt; /root/.pip/pip.conf echo `python3 -V`# 安装chromeRUN echo &#x27;[google-chrome]&#x27; &gt; /etc/yum.repos.d/google-chrome.repo &amp;&amp; \\ echo &#x27;name=google-chrome&#x27; &gt;&gt; /etc/yum.repos.d/google-chrome.repo &amp;&amp; \\ echo &#x27;baseurl=http://dl.google.com/linux/chrome/rpm/stable/$basearch&#x27; &gt;&gt; /etc/yum.repos.d/google-chrome.repo &amp;&amp; \\ echo &#x27;enabled=1&#x27; &gt;&gt; /etc/yum.repos.d/google-chrome.repo &amp;&amp; \\ echo &#x27;gpgcheck=1&#x27; &gt;&gt; /etc/yum.repos.d/google-chrome.repo &amp;&amp; \\ echo &#x27;gpgkey=https://dl-ssl.google.com/linux/linux_signing_key.pub&#x27; &gt;&gt; /etc/yum.repos.d/google-chrome.repo &amp;&amp; \\ yum -y install google-chrome-stable --nogpgcheck &amp;&amp; \\ echo `google-chrome --version`# 安装chromedriver驱动# 安装allureRUN rm -rf jdk-8u271-linux-x64.tar.gz &amp;&amp; \\ rm -rf Python-3.7.8.tgz &amp;&amp; \\ yum clean all","categories":[],"tags":[{"name":"Docker, 自动化测试","slug":"Docker-自动化测试","permalink":"https://linvaux.github.io/tags/Docker-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"}]},{"title":"基于Centos7的Python3.7镜像构建","slug":"基于Centos7的Python3-7镜像构建","date":"2024-07-25T15:07:16.000Z","updated":"2024-07-25T15:07:40.904Z","comments":true,"path":"2024/07/25/基于Centos7的Python3-7镜像构建/","permalink":"https://linvaux.github.io/2024/07/25/%E5%9F%BA%E4%BA%8ECentos7%E7%9A%84Python3-7%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA/","excerpt":"","text":"Dockerfile123456789101112131415161718192021222324252627282930FROM centos:7MAINTAINER linvaux &lt;linvaux@outlook.com&gt;WORKDIR /optRUN sed -i &quot;s/#baseurl/baseurl/g&quot; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\ sed -i &quot;s/mirrorlist=http/#mirrorlist=http/g&quot; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\ sed -i &quot;s@http://mirror.centos.org@https://repo.huaweicloud.com@g&quot; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\ yum clean all &amp;&amp; \\ yum makecache &amp;&amp; \\ yum update -yRUN yum install -y wget zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc makeRUN wget https://mirrors.huaweicloud.com/python/3.7.8/Python-3.7.8.tgz &amp;&amp; \\ tar -vxf Python-3.7.8.tgz &amp;&amp; \\ mv Python-3.7.8 /usr/local/python378 &amp;&amp; \\ cd /usr/local/python378 &amp;&amp; \\ ./configure --prefix=/usr/local/python378 --enable-loadable-sqlite-extensions --with-ssl &amp;&amp;\\ make -j$(nproc) &amp;&amp; \\ make install -j$(nproc) &amp;&amp; \\ ln -s /usr/local/python378/bin/python3.7 /usr/bin/python3 &amp;&amp; \\ ln -s /usr/local/python378/bin/pip3 /usr/bin/pip3 &amp;&amp; \\ mkdir /root/.pip &amp;&amp; \\ echo &quot;[global]&quot; &gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;index-url=https://pypi.douban.com/simple/&quot; &gt;&gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;[install]&quot; &gt;&gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;trusted-host=pypi.douban.com&quot; &gt;&gt; /root/.pip/pip.confRUN rm -rf Python-3.7.8.tgz 构建命令1docker build -t centos-python378 .","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://linvaux.github.io/tags/Docker/"}]},{"title":"基于Ubuntu16.04的Python3.7镜像构建","slug":"基于Ubuntu16-04的Python3-7镜像构建","date":"2024-07-25T15:06:21.000Z","updated":"2024-07-25T15:06:40.594Z","comments":true,"path":"2024/07/25/基于Ubuntu16-04的Python3-7镜像构建/","permalink":"https://linvaux.github.io/2024/07/25/%E5%9F%BA%E4%BA%8EUbuntu16-04%E7%9A%84Python3-7%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA/","excerpt":"","text":"Dockerfile12345678910111213141516171819202122232425262728FROM ubuntu:16.04MAINTAINER linvaux &lt;linvaux@outlook.com&gt;WORKDIR /optRUN sed -i &quot;s@http://.*archive.ubuntu.com@http://repo.huaweicloud.com@g&quot; /etc/apt/sources.list &amp;&amp; \\ sed -i &quot;s@http://.*security.ubuntu.com@http://repo.huaweicloud.com@g&quot; /etc/apt/sources.list &amp;&amp; \\ apt-get update &amp;&amp; \\ apt-get upgrade -yRUN apt-get install -y gcc make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev xz-utils tk-dev libffi-dev liblzma-devRUN wget https://mirrors.huaweicloud.com/python/3.7.8/Python-3.7.8.tgz &amp;&amp; \\ tar -vxf Python-3.7.8.tgz &amp;&amp; \\ mv Python-3.7.8 /usr/local/python378 &amp;&amp; \\ cd /usr/local/python378 &amp;&amp; \\ ./configure --prefix=/usr/local/python378 --enable-loadable-sqlite-extensions --with-ssl &amp;&amp;\\ make -j$(nproc) &amp;&amp; \\ make install -j$(nproc) &amp;&amp; \\ ln -s /usr/local/python378/bin/python3.7 /usr/bin/python3 &amp;&amp; \\ ln -s /usr/local/python378/bin/pip3 /usr/bin/pip3 &amp;&amp; \\ mkdir /root/.pip &amp;&amp; \\ echo &quot;[global]&quot; &gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;index-url=https://pypi.douban.com/simple/&quot; &gt;&gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;[install]&quot; &gt;&gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;trusted-host=pypi.douban.com&quot; &gt;&gt; /root/.pip/pip.confRUN rm -rf Python-3.7.8.tgz 构建命令1docker build -t ubuntu-python378 .","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://linvaux.github.io/tags/Docker/"}]},{"title":"CentOS安装Google-Chrome浏览器","slug":"CentOS安装Google-Chrome浏览器","date":"2024-07-25T15:05:23.000Z","updated":"2024-07-25T15:06:01.769Z","comments":true,"path":"2024/07/25/CentOS安装Google-Chrome浏览器/","permalink":"https://linvaux.github.io/2024/07/25/CentOS%E5%AE%89%E8%A3%85Google-Chrome%E6%B5%8F%E8%A7%88%E5%99%A8/","excerpt":"","text":"配置yum源 在目录 &#x2F;etc&#x2F;yum.repos.d&#x2F; 下新建文件 google-chrome.repo 1vim /etc/yum.repos.d/google-chrome.repo 添加如下内容 123456[google-chrome]name=google-chromebaseurl=http://dl.google.com/linux/chrome/rpm/stable/$basearchenabled=1gpgcheck=1gpgkey=https://dl-ssl.google.com/linux/linux_signing_key.pub 安装google chrome浏览器及chromedriver Google官方源安装： 12yum makecacheyum -y install google-chrome-stable Google官方源可能在中国无法使用，导致安装失败或者在国内无法更新，可以添加以下参数来安装： 1yum -y install google-chrome-stable --nogpgcheck 检查chrome版本 1google-chrome --version 下载对应版本的的chromedriver 检查chromedriver版本 1chromedriver --version","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://linvaux.github.io/tags/Docker/"}]},{"title":"Mac使用Jenv实现Jdk多版本管理","slug":"Mac使用Jenv实现Jdk多版本管理","date":"2024-07-25T14:53:58.000Z","updated":"2024-07-25T15:00:39.446Z","comments":true,"path":"2024/07/25/Mac使用Jenv实现Jdk多版本管理/","permalink":"https://linvaux.github.io/2024/07/25/Mac%E4%BD%BF%E7%94%A8Jenv%E5%AE%9E%E7%8E%B0Jdk%E5%A4%9A%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/","excerpt":"","text":"前言目前在开发过程中，需要同时安装 Jdk8, Jdk11, Jdk17 进行项目开发，为了统一管理Jdk 环境，需要一款类似 conda 的工具来管理多套 Jdk 环境，可选的方案有以下几种： 使用 shell 脚本来动态设置 JAVA_HOME； 使用 scoop 来管理环境； 使用 jenv 来管理环境； 经过使用体验，最后选择了 jenv 来做 jdk 版本管理。 安装在 mac 下面可以使用 brew 来安装 jenv 1brew install jenv 我用的 zsh，因此还需要将 jenv 添加到 zsh 中 123echo &#x27;export PATH=&quot;$HOME/.jenv/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc# 执行 jenv 初始化脚本，类似于 conda init 命令echo &#x27;eval &quot;$(jenv init -)&quot;&#x27; &gt;&gt; ~/.zshrc 配置1.添加在本地已经安装的 jdk123jenv add /Library/Java/JavaVirtualMachines/jdk-17.0.5.jdk/Contents/Home/jenv add /Library/Java/JavaVirtualMachines/jdk1.8.0_301.jdk/Contents/Home/jenv add /Library/Java/JavaVirtualMachines/jdk-11.0.11.jdk/Contents/Home/ 2.列出已经添加的 jdk 版本1jenv versions 3.设置 jdk 的三种方式 jenv local ：该命令将会在当前目录下设置特定的 Java 版本。这意味着只有在该目录下执行程序调用时才会使用该版本的 Java。 jenv global ：该命令将会设置系统全局的 Java 版本。当在终端或其它地方运行 Java 应用程序时，都将使用该版本的 Java。 jenv shell ：该命令将会在当前 Shell 会话中设置特定的 Java 版本。这意味着只有在该 Shell 会话中执行程序调用时才会使用该版本的 Java。 因此，这三个命令的主要区别在于设置 Java 版本的作用域和范围。jenv local 的作用域仅限于当前工作目录，jenv global 的作用域与操作系统全局环境相关，而 jenv shell 的作用域仅限于当前 Shell 会话。因此，根据具体情况选择使用不同的命令。需要注意的是，jenv 只对使用 jenv exec 执行的命令生效，对于直接使用 java 命令执行的程序，jenv 并不会自动切换 Java 版本。因此，需要手动设置系统环境变量或使用别的工具来切换 Java 版本。 4.Jenv 诊断jenv doctor 是 jenv 命令行工具提供的一个诊断工具，用于检查本地系统的 Java 环境是否正确配置。当我们安装 jenv 后，需要将其配置到系统环境变量中，并安装所需的 Java 版本。使用 jenv doctor 命令可以检测配置和 Java 版本是否正确安装，并提供诊断信息和建议以解决检测出的问题。jenv doctor 常见的使用场景有： 检查 jenv 的环境变量是否正确配置。jenv 是一款基于环境变量来管理多个 Java 版本的工具，因此我们需要将其配置到系统环境变量中，并确保环境变量的正确性。 检查 jenv 的安装路径和版本号。检查 jenv 实际安装的位置以及当前所用的版本号，是否符合预期要求。 检查可用的 Java 版本是否正确安装和配置。jenv doctor 会检查本地系统环境中已经安装的 Java 版本，是否安装在了 jenv 管理的目录中，并支持在 jenv 中进行切换。 参考文档 Jenv 官方文档","categories":[{"name":"工具分享","slug":"工具分享","permalink":"https://linvaux.github.io/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Mac, JDK","slug":"Mac-JDK","permalink":"https://linvaux.github.io/tags/Mac-JDK/"}]},{"title":"Pytest参数","slug":"Pytest参数","date":"2024-07-25T14:40:14.000Z","updated":"2024-07-25T14:40:51.371Z","comments":true,"path":"2024/07/25/Pytest参数/","permalink":"https://linvaux.github.io/2024/07/25/Pytest%E5%8F%82%E6%95%B0/","excerpt":"","text":"分类 参数 作用 general -k 支持python的表达式，用于筛选指定标记&#x2F;方法名的用例 -m 根据用例标签来筛选用例，设置标签可以使用 @pytest.mark.&lt;标签名&gt; –markers 打印标签，包括内置的，插件的，还有自定义的 -x 第一个error或failed的test就退出 –fixtures 显示可用的fixture，包括内置和自己写的，如果fixture使用 “_”开头则需要使用-v才能显示此fixture –fixtures-per-test 展示每条用例的fixture –pdb 当用例出现错误或者被键盘中断后，启动pdb调试 –pdbcls&#x3D;modulename:classname 启动自定义pdb debugger，一般用不到这个 –trace 执行测试用例时break，进入debugger –capture&#x3D;method 标准输出&#x2F;标准错误输出&#x2F;标准输入的默认捕获，fd：标准输入，标准错误输出都会捕获；sys：只有向Python的sys.stdout和sys.stderr的写入行为会被捕获，不执行对文件描述符的写入的捕获；no：对print语句内容捕获，等同于 -s -s 显示print语句的内容 –runxfail 强制运行xfail标记的用例 –lf, –last-failed 重新执行上次测试执行失败的用例，如果没有失败的用例，则执行全部用例 –ff, –failed-first 优先跑上次失败的test，tests的顺序会被打乱 –nf, –new-first 优先跑新添加的tests，剩余的按文件mtime顺序 –cache-show&#x3D;[CACHESHOW] 显示缓存，默认 * 显示所有缓存，可以带参数 pytest –cache-show&#x3D;cache&#x2F;nodeids –cache-clear 在执行用例前，清理pytest缓存 –lfnf&#x3D;{all,none}, –last-failed-no-failures&#x3D;{all,none} 没有last-failed缓存数据，或上次没有失败时，执行全部用例 –sw, –stepwise 逐步运行，在失败时退出，下次运行时从失败的用例开始 –stepwise-skip 跳过第一个失败的test，如果再遇到失败就退出 reporting –durations&#x3D;N 显示N个最慢的setup&#x2F;test的耗时，N&#x3D;0时，显示所有耗时 –durations-min&#x3D;N 显示N个最小的setup&#x2F;test的耗时 -v, –verbose 输出详细信息 –no-header 不显示pytest消息头，只展示用例信息 –no-summary 不显示用例执行完的summary info -q, –quiet 静默模式，不输出任何内容 –verbosity&#x3D;VERBOSE 信息显示等级，貌似没啥用 -r chars -r f：显示failed信息；-r E：显示error信息；-r s：显示skipped信息；-r x：显示xfailed信息；-r X：显示xpassed信息；-r p：显示passed信息；-r P：显示 passed with output信息； -r a&#x2F;A：显示 all except passed信息；-r w：显示默认告警信息；-r N：重置list –disable-warnings, –disable-pytest-warnings 禁用pytest告警，如未注册的标记等 -l, –showlocal 用例执行失败时，打印堆栈信息，默认被禁用 –tb&#x3D;style traceback打印模式，一般设置为auto即可 –show-capture&#x3D;{no,stdout,stderr,log,all} 失败的用例如何显示，默认为all –full-trace 不截取traceback，默认会截断 –color&#x3D;color 是否显示彩色，yes：显示颜色；no：不显示颜色；auto：自动 –code-highlight&#x3D;{yes,no} 代码是否高亮显示，一般用不到 –pastebin&#x3D;mode 没什么用的参数，我也不知道干嘛的 –junit-xml&#x3D;path 在给定的path路径下生成junit-xml风格的测试报告 –junit-prefix&#x3D;str 在junit-xml输出中的classnames添加前缀 pytest-warnings -W PYTHONWARNINGS, –pythonwarnings&#x3D;PYTHONWARNINGS 设置报告哪些warnings –maxfail&#x3D;num 出现num个errors或者fails就退出测试 –strict-config 解析配置文件中pytest部分时，遇到warning就抛出error –strict-markers, –strict 发现未知标记时，抛出error， -c file 从指定配置文件加载配置，默认为pytes.ini –continue-on-collection-errors 在收集用例时发生错误，也会继续执行用例 –rootdir&#x3D;ROOTDIR tests根目录，相对路径 collection –collect-only, –co 收集用例，但不执行 –pyargs 把所有参数解释为python包 –ignore&#x3D;path 忽略测试目录，使用英文逗号分割 –ignore-glob&#x3D;path path匹配多个不需要收集的测试目录，使用英文逗号分割 –deselect&#x3D;nodeid_prefix 通过node id prefix反选。可以多个，使用英文逗号分隔 –confcutdir&#x3D;dir 只加载相对于dir目录的conftest.py文件 –noconftest 不加载conftest.py文件 –keep-duplicates 收集重复的test文件，默认只会收集1item，加参数后会收集2items –collect-in-virtualenv 收集本地虚拟环境目录的tests –import-mode&#x3D;{prepend,append,importlib} 包导入模式，一般用不到，参考：https://www.osgeo.cn/pytest/pythonpath.html?highlight=import%20mode –doctest-modules 文档测试，没啥用 –doctest-report&#x3D;{none,cdiff,ndiff,udiff,only_first_failure} 一样，也没啥用 –doctest-glob&#x3D;pat 还是没啥用 –doctest-ignore-import-errors 文档测试时忽略导包错误，继续没什么用 –doctest-continue-on-failure 文档测试时出现失败继续测试，依然没什么用 test session debugging and configuration –basetemp&#x3D;dir test run的base临时目录（如果存在会先删除） -V, –version 输出pytest版本 -h, –help 打印pytest帮助信息 -p name 加载插件，一般不会控制此参数 –trace-config 查看本地安装好的第三方插件 –debug 保存debug信息到’pytestdebug.log’文件 -o OVERRIDE_INI, –override-ini&#x3D;OVERRIDE_INI 覆盖ini文件配置 –assert&#x3D;MODE 断言模式，默认rewrite –setup-only 只加载fixture，不执行测试用例 –setup-show 在执行测试用例时，打印fixture步骤 –setup-plan 展示哪些用例和fixture将要被执行 logging –log-level&#x3D;LEVEL 日志等级，默认 WARNING （具体日志等级参考 logging 模块中的日志等级） –log-format&#x3D;LOG_FORMAT 日志格式（具体日志格式参考 logging 模块中的日志格式） –log-date-format&#x3D;LOG_DATE_FORMA 日志日期格式（具体日志格式参考 logging 模块中的日志格式） –log-cli-level&#x3D;LOG_CLI_LEVEL cli日志等级（具体日志等级参考 logging 模块中的日志等级） –log-cli-format&#x3D;LOG_CLI_FORMAT cli日志格式（具体日志格式参考 logging 模块中的日志格式） –log-cli-date-format&#x3D;LOG_CLI_DATE_FORMAT cli日志日期格式（具体日志格式参考 logging 模块中的日志格式） –log-file&#x3D;LOG_FILE 日志文件路径 –log-file-level&#x3D;LOG_FILE_LEVE 日志文件中的日志等级 –log-file-format&#x3D;LOG_FILE_FORMAT 日志文件中的日志格式 –log-file-date-format&#x3D;LOG_FILE_DATE_FORMAT 日志文件中的日志时间格式 –log-auto-indent&#x3D;LOG_AUTO_INDENT 自动缩进传递给日志模块的多行消息。接受true | on、false | off或整数","categories":[{"name":"测试","slug":"测试","permalink":"https://linvaux.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"Pytest","slug":"Pytest","permalink":"https://linvaux.github.io/tags/Pytest/"}]}],"categories":[{"name":"工具分享","slug":"工具分享","permalink":"https://linvaux.github.io/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"},{"name":"测试","slug":"测试","permalink":"https://linvaux.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"Java, IDEA","slug":"Java-IDEA","permalink":"https://linvaux.github.io/tags/Java-IDEA/"},{"name":"Java, EasyExcel","slug":"Java-EasyExcel","permalink":"https://linvaux.github.io/tags/Java-EasyExcel/"},{"name":"Docker, 自动化测试","slug":"Docker-自动化测试","permalink":"https://linvaux.github.io/tags/Docker-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"Docker","slug":"Docker","permalink":"https://linvaux.github.io/tags/Docker/"},{"name":"Mac, JDK","slug":"Mac-JDK","permalink":"https://linvaux.github.io/tags/Mac-JDK/"},{"name":"Pytest","slug":"Pytest","permalink":"https://linvaux.github.io/tags/Pytest/"}]}