{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://linvaux.github.io","root":"/"},"pages":[{"title":"categories","date":"2024-07-25T14:43:59.000Z","updated":"2024-07-25T14:43:59.465Z","comments":true,"path":"categories/index.html","permalink":"https://linvaux.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2024-07-25T14:43:48.000Z","updated":"2024-07-25T14:43:48.484Z","comments":true,"path":"tags/index.html","permalink":"https://linvaux.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Jdk11获取系统信息","slug":"Jdk11获取系统信息","date":"2024-07-26T14:01:20.000Z","updated":"2024-07-26T14:02:01.734Z","comments":true,"path":"2024/07/26/Jdk11获取系统信息/","permalink":"https://linvaux.github.io/2024/07/26/Jdk11%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/","excerpt":"","text":"下面用到的 api 仅在 jdk11 上测试通过，其他 jdk 版本没试过 工具类 SystemInfoUtils.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import com.demo.constant.SystemInfoConstant;import com.sun.management.OperatingSystemMXBean;import lombok.extern.slf4j.Slf4j;import java.lang.management.ManagementFactory;import java.net.InetAddress;import java.net.NetworkInterface;import java.nio.file.*;import java.text.DecimalFormat;import java.util.ArrayList;import java.util.Enumeration;import java.util.List;import java.util.stream.Collectors;/** * @description: 系统信息工具类 */@Slf4jpublic class SystemInfoUtils &#123; /** * 获取本地IP地址 * @return 本机 ip，过滤了回环地址和 localhost */ public static List&lt;String&gt; getLocalIP() &#123; List&lt;String&gt; ipList = new ArrayList&lt;&gt;(); try &#123; // 获取本地所有网络接口 Enumeration&lt;NetworkInterface&gt; networkInterfaces = NetworkInterface.getNetworkInterfaces(); while (networkInterfaces.hasMoreElements()) &#123; NetworkInterface networkInterface = networkInterfaces.nextElement(); // 排除虚拟接口和未启用的接口 if (networkInterface.isVirtual() || !networkInterface.isUp()) &#123; continue; &#125; Enumeration&lt;InetAddress&gt; inetAddresses = networkInterface.getInetAddresses(); while (inetAddresses.hasMoreElements()) &#123; InetAddress inetAddress = inetAddresses.nextElement(); if (!inetAddress.isLinkLocalAddress()) &#123; ipList.add(inetAddress.getHostAddress()); &#125; &#125; &#125; &#125; catch (Exception e) &#123; log.error(&quot;本机 IP 获取失败, 异常详情: &quot; + ExceptionUtil.getErrorMessage(e)); &#125; return ipList.stream().filter(e -&gt; !SystemInfoConstant.INVALID_IP_LIST.contains(e)).collect(Collectors.toList()); &#125; /** * 获取CPU数量 * @return 逻辑处理器数量，物理核数 * 2 */ public static int getCpuCount() &#123; // 此处有坑，OperatingSystemMXBean 存在于两个包：java.lang.management.OperatingSystemMXBean 和 com.sun.management.OperatingSystemMXBean // 一定要找对包，不然有些方法找不到，太特么坑了 java.lang.management.OperatingSystemMXBean operatingSystemMXBean = ManagementFactory.getOperatingSystemMXBean(); return operatingSystemMXBean.getAvailableProcessors(); &#125; /** * 获取总内存大小 * @return 物理内存大小 */ public static String getTotalPhysicalMemory() &#123; OperatingSystemMXBean osBean = ManagementFactory.getPlatformMXBean(OperatingSystemMXBean.class); long physicalMemorySize = osBean.getTotalPhysicalMemorySize(); double physicalMemoryGB = (double) physicalMemorySize / 1024 / 1024 / 1024; DecimalFormat decimalFormat = new DecimalFormat(&quot;#.##&quot;); return decimalFormat.format(physicalMemoryGB) + &quot;GB&quot;; &#125; /** * 获取磁盘总大小 * @return 磁盘总量 */ public static String getDiskSizeTotal() &#123; String diskSize = null; try &#123; Path rootDir = Paths.get(&quot;/&quot;); FileStore store = Files.getFileStore(rootDir); long totalSpace = store.getTotalSpace(); double totalGB = (double) totalSpace / 1024 / 1024 / 1024; DecimalFormat decimalFormat = new DecimalFormat(&quot;#.##&quot;); diskSize = decimalFormat.format(totalGB + &quot;GB&quot;); &#125; catch (Exception e) &#123; log.error(&quot;磁盘信息获取失败, 异常详情: &#123;&#125;&quot;, ExceptionUtil.getErrorMessage(e)); &#125; return diskSize; &#125; /** * 获取已使用磁盘大小 * @return 磁盘已使用量 */ public static String getDiskSizeUsed() &#123; String diskSize = null; try &#123; Path rootDir = Paths.get(&quot;/&quot;); FileStore store = Files.getFileStore(rootDir); long usableSpace = store.getUsableSpace(); double usableGB = (double) usableSpace / 1024 / 1024 / 1024; DecimalFormat decimalFormat = new DecimalFormat(&quot;#.##&quot;); diskSize = decimalFormat.format(usableGB + &quot;GB&quot;); &#125; catch (Exception e) &#123; log.error(&quot;磁盘信息获取失败, 异常详情: &#123;&#125;&quot;, ExceptionUtil.getErrorMessage(e)); &#125; return diskSize; &#125; /** * 获取可用磁盘大小 * @return 磁盘可使用量 */ public static String getDiskSizeFree() &#123; String diskSize = null; try &#123; Path rootDir = Paths.get(&quot;/&quot;); FileStore store = Files.getFileStore(rootDir); long freeSpace = store.getUnallocatedSpace(); double freeGB = (double) freeSpace / 1024 / 1024 / 1024; DecimalFormat decimalFormat = new DecimalFormat(&quot;#.##&quot;); diskSize = decimalFormat.format(freeGB + &quot;GB&quot;); &#125; catch (Exception e) &#123; log.error(&quot;磁盘信息获取失败, 异常详情: &#123;&#125;&quot;, ExceptionUtil.getErrorMessage(e)); &#125; return diskSize; &#125;&#125; 常量类 SystemInfoConstant.java1234567891011121314151617181920212223242526import java.util.List;/** * @description: 系统信息常量 */public class SystemInfoConstant &#123; /** * ipv4 回环地址 */ public static final String IPV4_LOOP_ADDRESS = &quot;0.0.1.1&quot;; /** * ipv6 回环地址 */ public static final String IPV6_LOOP_ADDRESS = &quot;0:0:0:0:0:0:0:1%lo0&quot;; /** * 本机 IP */ public static final String LOCAL_HOST = &quot;127.0.0.1&quot;; /** * 无效的 ip 地址列表，需要排除 */ public static final List&lt;String&gt; INVALID_IP_LIST = List.of(IPV4_LOOP_ADDRESS, IPV6_LOOP_ADDRESS, LOCAL_HOST); 异常信息获取工具类 ExceptionUtil.java123456789101112131415161718192021222324252627282930import org.springframework.util.StringUtils;import java.io.PrintWriter;import java.io.StringWriter;/** * @description: 异常工具类 */public class ExceptionUtil &#123; /** * 异常信息允许的最大长度，超过这个长度会被截取 */ private static final Integer ERROR_MSG_MAX_LENGTH = 2000; /** * 获取异常的堆栈信息 * * @param e 异常对象 * @return 堆栈信息 */ public static String getErrorMessage(Exception e) &#123; if (StringUtils.hasText(e.getMessage())) &#123; return e.getMessage(); &#125; StringWriter sw = new StringWriter(); e.printStackTrace(new PrintWriter(sw, Boolean.TRUE)); String message = sw.toString(); return message.length() &gt; ERROR_MSG_MAX_LENGTH ? message.substring(0, ERROR_MSG_MAX_LENGTH) : message; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://linvaux.github.io/tags/Java/"}]},{"title":"IDEA高效使用指南(一)","slug":"IDEA高效使用指南（一）","date":"2024-07-26T13:48:42.000Z","updated":"2024-07-26T13:49:51.460Z","comments":true,"path":"2024/07/26/IDEA高效使用指南（一）/","permalink":"https://linvaux.github.io/2024/07/26/IDEA%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"设置全局 JDK File -&gt; New Projects Setup -&gt; Structure… Maven 配置 Perferences -&gt; Build,Execution,Deployment -&gt; Build Tools -&gt; Maven 自动导包&#x2F;删除无用包 Perferences -&gt; Editor -&gt; General -&gt; Auto Import 注释模板 Perferences -&gt; Editor -&gt; File and Code Templates class 注释模板示例 123456789#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != &quot;&quot;)package $&#123;PACKAGE_NAME&#125;;#end#parse(&quot;File Header.java&quot;)/** * @author: $&#123;USER&#125; * @date: $&#123;DATE&#125; $&#123;TIME&#125; * @description: */public class $&#123;NAME&#125; &#123;&#125; 显示方法分割线 Perferences -&gt; Editor -&gt; General -&gt; Appearance 代码自动补全 Perferences -&gt; Editor -&gt; General -&gt; Code Completion 设置每行代码最大长度 Perferences -&gt; Editor -&gt; Code Style 阿里巴巴的 Java 开发规范推荐每行长度不要超过 120，但是我习惯用 200 修改注释颜色 Perferences -&gt; Editor -&gt; Color Scheme -&gt; Java 去掉Inherit values from 前面的√，选中 Foreground 自己设置个喜欢的颜色 这是我现在的配置 Line comment: FFB704, Text: 02FA15 禁止 IDEA 启动时，自动打开上一个项目 Perperences -&gt; Appearance &amp; Behavior -&gt; System Settings 修改字体 Perferences -&gt; Editor -&gt; Font 我习惯使用 Consolas 字体，但是 mac 上默认没有这个字体，需要自行安装: http://www.fontpalace.com/font-details/Consolas/ 修改文件编码 Perferences -&gt; Editor -&gt; File Encodings 直接使用 UTF-8 编码即可，如果出现乱码，记得勾选下面的 Transparent native-to-ascii conversion 修改 IDEA 的 JVM 堆配置 IDEA 默认的堆配置貌似是 750MB，启动一个大型项目时，这点内存不大够用，可以自己通过如下配置修改 help -&gt; Edit custom VM options 修改配置 -Xmx8192m, 按照自己电脑内存大小配置 窗口多标签换行显示 Perferences -&gt; Editor -&gt; General -&gt; Editor Tabs 标识修改过的文件 Perferences -&gt; Editor -&gt; General -&gt; Editor Tabs 实现 Serializable 接口时，提示生成 SerialVersionUID Perferences -&gt; Editor -&gt; Inspections 在实现了 Serializable 接口的类上使用快捷键 alt+enter,就会提示生成 SerialVersionUID","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://linvaux.github.io/tags/IDEA/"}]},{"title":"Centos使用Tomcat安装Jenkins","slug":"Centos使用Tomcat安装Jenkins","date":"2024-07-26T13:47:23.000Z","updated":"2024-07-26T13:47:37.870Z","comments":true,"path":"2024/07/26/Centos使用Tomcat安装Jenkins/","permalink":"https://linvaux.github.io/2024/07/26/Centos%E4%BD%BF%E7%94%A8Tomcat%E5%AE%89%E8%A3%85Jenkins/","excerpt":"","text":"安装步骤安装JDK1.812yum makecacheyum install -y java-1.8.0-openjdk.x86_64 安装tomcat1234567# 下载tomcat9.0wget https://mirrors.bfsu.edu.cn/apache/tomcat/tomcat-9/v9.0.36/bin/apache-tomcat-9.0.36.tar.gz &amp;&amp; tar -xvf apache-tomcat-9.0.36.tar.gz# 删除webapps下面的项目cd apache-tomcat-9.0.36/webapps/ &amp;&amp; rm -rf *# 下载jenkins.war并重命名为ROOT.warwget https://mirrors.huaweicloud.com/jenkins/war/2.240/jenkins.war -O ROOT.war 修改Tomcat启动脚本，支持Jenkins跨域12345# 修改bin/catalina.sh,在首行添加如下参数export CATALINA_OPTS=&quot;-Djava.awt.headless=true&quot;export JAVA_OPTS=&quot;-Dhudson.model.DirectoryBrowserSupport.CSP= &quot;# 启动tomcat./startup.sh 关闭防火墙12systemctl stop firewalldsystemctl disable firewalld 访问jenkins tomcat默认监听端口是8080，访问 192.168.1.2:8080 如果jenkins启动页面可以正常打开，此时，停止tomcat，并修改jenkins配置。 12bash &lt;tomcat安装目录&gt;/bin/shutdown.shcd ~/.jenkins/ 找到hudson.model.UpdateCenter.xml文件，修改为如下内容 1234567&lt;?xml version=&#x27;1.1&#x27; encoding=&#x27;UTF-8&#x27;?&gt;&lt;sites&gt; &lt;site&gt; &lt;id&gt;default&lt;/id&gt; &lt;url&gt;https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json&lt;/url&gt; &lt;/site&gt;&lt;/sites&gt; 启动tomcat jenkins启动后，需要输入初始化密码，根据页面提示填写密码后，进入插件安装页面，此时，需要再次停止tomcat，然后执行以下命令，更换jenkins更新源之后，再次启动tomcat。 123cd ~/.jenkins/updates;sed -i &#x27;s/http:\\/\\/updates.jenkins-ci.org\\/download/https:\\/\\/mirrors.tuna.tsinghua.edu.cn\\/jenkins/g&#x27; default.json &amp;&amp; sed -i &#x27;s/http:\\/\\/www.google.com/https:\\/\\/www.baidu.com/g&#x27; default.json;bash &lt;tomcat安装目录&gt;/bin/startup.sh 此时，jenkins会要求重新输入初始化密码，然后选择安装建议的插件，等待安装完成。 插件安装完成后，需要设置管理员信息，之后进入jenkins工作页面。 jenkins常用插件 chinese （汉化） locale（汉化） blue ocean（流水线工具） Allure Jenkins Plugin (allure报告) Extended Choice Parameter Plug-In (参数化构建扩展) AnsiColor （日志彩色输出） Git Parameter Plug-In（代码分支选择） build failure analyzer (构建失败分析) multijob（组织多job构建） multiple SCMs （设置多个git） simple theme（jenkins主题 http://afonsof.com/jenkins-material-theme/） merge request event (gitlab 代码门禁) SLOCCount Plug-in（clco代码量统计结果展示） Warnings Next Generation Plugin（代码静态扫描结果展示 https://github.com/jenkinsci/warnings-ng-plugin/blob/master/SUPPORTED-FORMATS.md） Jacoco（java代码覆盖率报告） Html publisher（生成html报告） backup（备份&#x2F;恢复jenkins） Gitlab（gitlab支持插件） Gitee（gitee支持插件） Role-based Authorization Strategy (角色权限控制) Active Choices (根据所选参数，自动调出对应参数所依赖的后续参数) Job Configuration History (配置记录管理，支持配置回滚)","categories":[],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://linvaux.github.io/tags/Jenkins/"}]},{"title":"Springboot业务信息国际化","slug":"Springboot业务信息国际化","date":"2024-07-26T13:43:49.000Z","updated":"2024-07-26T13:46:30.462Z","comments":true,"path":"2024/07/26/Springboot业务信息国际化/","permalink":"https://linvaux.github.io/2024/07/26/Springboot%E4%B8%9A%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%9B%BD%E9%99%85%E5%8C%96/","excerpt":"","text":"业务背景用户上传一个 excel 文件，要对 excel 内容做校验，然后返回校验结果。校验通过之后，在执行导入。但是现在平台要做国际化，支持中英双语，目前校验结果是直接中文返回，为了完成国际化需求，需要根据请求头中的 Accept-language 来决定返回何种语言的内容。 当前处理方式 国际化方案使用工具类获取国际化内容1234567891011121314151617181920212223242526272829303132333435363738394041import org.springframework.context.MessageSource;import org.springframework.context.MessageSourceAware;import org.springframework.context.support.MessageSourceAccessor;import org.springframework.stereotype.Component;@Componentpublic class I18nMessageUtil implements MessageSourceAware &#123; private static MessageSourceAccessor accessor; /** * 获取i18n文件中对应的国际化信息 * * @param code i18n文件中code * @param locale 地区信息 * @param args 参数 * @return 国际化信息 */ public static String getMessage(String code, Locale locale, Object... args) &#123; if (locale == null) &#123; return accessor.getMessage(code, args); &#125; return accessor.getMessage(code, args, locale); &#125; /** * 获取i18n文件中对应的国际化信息,如果不传locale信息，则从当前request获取，如果还是没有，则使用默认locale * * @param code i18n文件中code * @param args 参数 * @return 国际化信息 */ public static String getMessage(String code, Object... args) &#123; return accessor.getMessage(code, args); &#125; @Override public void setMessageSource(MessageSource messageSource) &#123; I18nMessageUtil.accessor = new MessageSourceAccessor(messageSource); &#125;&#125; 配置国际化文件12345678910111213141516171819202122232425import org.springframework.context.MessageSource;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.support.ResourceBundleMessageSource;import java.util.HashSet;import java.util.Set;@Configurationpublic class I18nConfig &#123; @Bean public MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); Set&lt;String&gt; i18nFolder = new HashSet&lt;&gt;(); // excel 校验的国际化文件 i18nFolder.add(&quot;i18n.excelValidation&quot;); // 默认的国际化文件 i18nFolder.add(&quot;i18n.messages&quot;); messageSource.setBasenames(i18nFolder.toArray(new String[0])); messageSource.setDefaultEncoding(&quot;UTF-8&quot;); messageSource.setUseCodeAsDefaultMessage(true); return messageSource; &#125;&#125; 编写国际化异常信息 替换校验异常信息","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://linvaux.github.io/tags/SpringBoot/"}]},{"title":"FileBeat+LogStash实现MySQL慢查询日志解析","slug":"FileBeat-LogStash实现MySQL慢查询日志解析","date":"2024-07-26T13:42:18.000Z","updated":"2024-07-26T13:43:16.162Z","comments":true,"path":"2024/07/26/FileBeat-LogStash实现MySQL慢查询日志解析/","permalink":"https://linvaux.github.io/2024/07/26/FileBeat-LogStash%E5%AE%9E%E7%8E%B0MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E8%A7%A3%E6%9E%90/","excerpt":"","text":"背景是一个大型营销系统经常出现mysql的慢查询，导致线上服务频繁出现故障，为了查看是哪些sql有问题，并且要支持各种维度的统计查询，所以使用FileBeat+LogStash+ElasticSearch+Kibana实现此需求。本文仅描述如何配置FileBeath和LogStash实现MySQL慢查询日志解析。 FileBeat配置12345678910111213141516171819filebeat.inputs:- type: log enabled: true # 忽略在指定的时间跨度之前被修改的文件 ignore_older: 30000h # mysql慢查询日志目录，支持*通配符匹配多级目录 paths: - /opt/slow-sql/*.log # 文档类型是mysqlslow，这是filebeat内置的一套规则 document_type: mysqlslow multiline: pattern: &quot;^# User@Host: &quot; negate: true match: after tail_files: falseoutput.logstash: # logstash的地址，我是部署在同一台机器上的 hosts: [&quot;127.0.0.1:5044&quot;] LogStash配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556input &#123; # 使用filebeat推送日志 beats &#123; port =&gt; 5044 host =&gt; &quot;0.0.0.0&quot; &#125;&#125;filter &#123; grok &#123; # 有数据库名，有schema match =&gt; &#123;&quot;message&quot; =&gt; &quot;(?m)^# User@Host: %&#123;USER:user&#125;\\[[^\\]]+\\]\\s@\\s*\\[%&#123;IP:clientip&#125;\\]\\s*([\\s\\S]*)#\\s+Schema: (?&lt;schema&gt;\\w+)([\\s\\S]*)\\s+#\\s+Query_time:\\s+%&#123;NUMBER:query_time:float&#125;\\s+Lock_time: %&#123;NUMBER:lock_time:float&#125;\\s+Rows_sent: %&#123;NUMBER:rows_sent:int&#125;\\s+Rows_examined: %&#123;NUMBER:rows_examined:int&#125;\\s*([\\s\\S]*)use\\s(?&lt;dbname&gt;\\w+);([\\s\\S]*)SET timestamp=%&#123;NUMBER:sql_time:int&#125;&quot;&#125; # 无数据库名,有schema match =&gt; &#123;&quot;message&quot; =&gt; &quot;(?m)^# User@Host: %&#123;USER:user&#125;\\[[^\\]]+\\]\\s@\\s*\\[%&#123;IP:clientip&#125;\\]\\s*([\\s\\S]*)#\\s+Schema: (?&lt;schema&gt;\\w+)([\\s\\S]*)\\s+#\\s+Query_time:\\s+%&#123;NUMBER:query_time:float&#125;\\s+Lock_time: %&#123;NUMBER:lock_time:float&#125;\\s+Rows_sent: %&#123;NUMBER:rows_sent:int&#125;\\s+Rows_examined: %&#123;NUMBER:rows_examined:int&#125;\\s*([\\s\\S]*)SET timestamp=%&#123;NUMBER:sql_time:int&#125;&quot;&#125; # 有数据库名，无schema match =&gt; &#123;&quot;message&quot; =&gt; &quot;(?m)^# User@Host: %&#123;USER:user&#125;\\[[^\\]]+\\]\\s@\\s*\\[%&#123;IP:clientip&#125;\\]\\s*([\\s\\S]*)#\\s+Query_time:\\s+%&#123;NUMBER:query_time:float&#125;\\s+Lock_time: %&#123;NUMBER:lock_time:float&#125;\\s+Rows_sent: %&#123;NUMBER:rows_sent:int&#125;\\s+Rows_examined: %&#123;NUMBER:rows_examined:int&#125;\\s*([\\s\\S]*)use\\s(?&lt;dbname&gt;\\w+);([\\s\\S]*)SET timestamp=%&#123;NUMBER:sql_time:int&#125;&quot;&#125; # 无数据库名,无schema match =&gt; &#123;&quot;message&quot; =&gt; &quot;(?m)^# User@Host: %&#123;USER:user&#125;\\[[^\\]]+\\]\\s@\\s*\\[%&#123;IP:clientip&#125;\\]\\s*([\\s\\S]*)#\\s+Query_time:\\s+%&#123;NUMBER:query_time:float&#125;\\s+Lock_time: %&#123;NUMBER:lock_time:float&#125;\\s+Rows_sent: %&#123;NUMBER:rows_sent:int&#125;\\s+Rows_examined: %&#123;NUMBER:rows_examined:int&#125;\\s*([\\s\\S]*)SET timestamp=%&#123;NUMBER:sql_time:int&#125;&quot;&#125; overwrite =&gt; [&quot;message&quot;] &#125; grok&#123; # 匹配 source中的ip match =&gt; &#123;&quot;source&quot; =&gt; &quot;(?m)\\s*%&#123;IP:server_ip&#125;&quot;&#125; &#125; # 时间戳格式化并只保留日期 ruby &#123; code =&gt; &quot; require &#x27;time&#x27; event.set(&#x27;date_tag&#x27;, Time.at(event.get(&#x27;sql_time&#x27;)).to_date.to_s.delete!(&#x27;-&#x27;)) &quot; &#125; # 索引时间戳使用sql生成的时间，不再使用当前时间 date &#123; match =&gt; [&quot;sql_time&quot;, &quot;yyyy-MM-dd HH:mm:ss&quot;, &quot;UNIX&quot;] target =&gt; &quot;@timestamp&quot; locale =&gt; &quot;cn&quot; &#125;&#125;output &#123; # 调试时使用，在控制台打印日志分割结果 stdout &#123; codec =&gt; rubydebug &#123;&#125; &#125; # es配置 elasticsearch &#123; hosts =&gt; &quot;localhost:9200&quot; # 索引名称 index =&gt; &quot;slow-sql-%&#123;+YYYY.MM.dd&#125;&quot; &#125; &#125; 一键安装ELFK123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#!/bin/bashecho &quot;#-----------------------------------------#@Author: linvaux #@Email: linvaux@outlook.com#@Desc: Auto install ELFK#----------------------------------------&quot;INFO()&#123; echo -e &quot;\\033[0;32m[INFO] $* \\033[0m&quot;&#125;ERROR()&#123; echo -e &quot;\\033[0;31m[ERROR] $* \\033[0m&quot;&#125;WARN()&#123; echo -e &quot;\\033[0;33m[WARN] $* \\033[0m&quot;&#125;# booster the docker-hubbooster()&#123; daemon=&quot;/etc/docker/daemon.json&quot; if [[ -e $&#123;daemon&#125; ]];then INFO Backup $&#123;daemon&#125; success! mv $&#123;daemon&#125; $&#123;daemon&#125;.bak echo &quot;&#123;\\&quot;registry-mirrors\\&quot; : [\\&quot;https://hub-mirror.c.163.com\\&quot;]&#125;&quot; &gt; $&#123;daemon&#125; else echo &quot;&#123;\\&quot;registry-mirrors\\&quot; : [\\&quot;https://hub-mirror.c.163.com\\&quot;]&#125;&quot; &gt; $&#123;daemon&#125; fi INFO Config docker-hub booster success!&#125;check_env()&#123; if [[ -z &quot;$(which docker)&quot; ]] then WARN No docker were found,try to install! INFO Start to install docker source /etc/os-release if [[ &quot;$ID&quot; == &quot;ubuntu&quot; ]] || [[ &quot;$ID&quot; == &quot;debain&quot; ]] then apt update apt install curl wget -y curl -fsSL https://get.docker.com | sh booster systemctl daemon-reload systemctl restart docker if [[ -z &quot;$(which java)&quot; ]];then apt install openjdk-8-jdk -y fi elif [[ &quot;$ID&quot; == &quot;centos&quot; ]] then yum update -y yum install wget curl net-tools -y curl -fsSL https://get.docker.com | sh booster systemctl daemon-reload systemctl restart docker if [[ -z &quot;$(which java)&quot; ]];then yum install java-1.8.0-openjdk -y fi else ERROR Could not support $ID platform! exit 1 fi fi&#125;install_elasticsearch()&#123; INFO Start to install elasticsearch echo &quot;vm.max_map_count=655360&quot; &gt;&gt; /etc/sysctl.conf sysctl -p docker pull docker.elastic.co/elasticsearch/elasticsearch:6.5.4 docker run -d --restart=always -p 9200:9200 -p 9300:9300 --name es -h es -e cluster.name=kiki -e node.name=node1 -e http.cors.enabled=true -e http.cors.allow-origin=&quot;*&quot; -e xpack.security.enabled=false docker.elastic.co/elasticsearch/elasticsearch:6.5.4&#125;install_kibana()&#123; INFO Start to install kibana docker pull kibana:6.5.4; docker run --restart=always -p 5601:5601 --name kibana -e ELASTICSEARCH_URL=http://127.0.0.1:9200 --network=host -d kibana:6.5.4&#125;install_filebeat_and_logstash()&#123; INFO Start to install filebeat and logstash source /etc/os-release if [[ &quot;$ID&quot; == &quot;ubuntu&quot; ]] || [[ &quot;$ID&quot; == &quot;debain&quot; ]] then wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add - apt-get install apt-transport-https -y echo &quot;deb https://artifacts.elastic.co/packages/6.x/apt stable main&quot; | sudo tee -a /etc/apt/sources.list.d/elastic-6.x.list apt-get update &amp;&amp; apt install filebeat logstash -y if [[ $? -ne 0 ]] then ERROR Install filebeat and logstash failed! exit 1 fi elif [[ &quot;$ID&quot; == &quot;centos&quot; ]] then rpm --import https://packages.elastic.co/GPG-KEY-elasticsearch echo -e &#x27;[elastic-6.x]name=Elastic repository for 6.x packagesbaseurl=https://artifacts.elastic.co/packages/6.x/yumgpgcheck=1gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearchenabled=1autorefresh=1type=rpm-md&#x27; &gt; /etc/yum.repos.d/elastic.io.repo yum makecache &amp;&amp; yum install filebeat logstash -y if [[ $? -ne 0 ]] then ERROR Install filebeat and logstash failed! exit 1 fi else ERROR Could not support $ID platform! exit 1 fi&#125;start_filebeat()&#123; INFO Start to call filebeat filebeat_yaml=&quot;/etc/filebeat/filebeat.yml&quot; if [[ -f $&#123;filebeat_yaml&#125; ]];then mv $&#123;filebeat_yaml&#125; $&#123;filebeat_yaml&#125;.bak cp ./filebeat.yml $&#123;filebeat_yaml&#125; systemctl restart filebeat if [[ $? -ne 0 ]] then ERROR Start filebeat failed! exit 1 fi else ERROR $&#123;filebeat_yaml&#125; not found, please check! exit 1 fi&#125;start_logstash()&#123; INFO Start to call logstash logstash_conf_dir=&quot;/etc/logstash/conf.d/&quot; if [[ -e $&#123;logstash_conf_dir&#125; ]];then cp ./slow_sql_by_query.conf $&#123;logstash_conf_dir&#125; systemctl restart logstash if [[ $? -ne 0 ]] then ERROR Start logstash failed! exit 1 fi else ERROR $&#123;logstash_conf_dir&#125; not found, please check! exit 1 fi&#125;run()&#123; if [[ &quot;root&quot; == $(whoami) ]] then INFO Start to run... check_env install_elasticsearch install_kibana install_filebeat_and_logstash # download_log start_logstash start_filebeat # check_index INFO Run success! else ERROR Run as root please! fi&#125;run","categories":[],"tags":[{"name":"LogStash","slug":"LogStash","permalink":"https://linvaux.github.io/tags/LogStash/"}]},{"title":"EasyExcel解决自定义样式太多导致的 The maximum number of Cell Styles was exceeded 异常","slug":"EasyExcel解决自定义样式太多导致的-The-maximum-number-of-Cell-Styles-was-exceeded-异常","date":"2024-07-26T13:38:50.000Z","updated":"2024-07-26T13:41:07.071Z","comments":true,"path":"2024/07/26/EasyExcel解决自定义样式太多导致的-The-maximum-number-of-Cell-Styles-was-exceeded-异常/","permalink":"https://linvaux.github.io/2024/07/26/EasyExcel%E8%A7%A3%E5%86%B3%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F%E5%A4%AA%E5%A4%9A%E5%AF%BC%E8%87%B4%E7%9A%84-The-maximum-number-of-Cell-Styles-was-exceeded-%E5%BC%82%E5%B8%B8/","excerpt":"","text":"之前使用自定义样式解决了导出excel时，对不同单元格使用不同样式的需求，但是最近发现，导出大量数据时，就会产生如下异常 1java.lang.IllegalStateException: The maximum number of Cell Styles was exceeded. You can define up to 64000 style in a .xlsx Workbook 通过查看easyexcel在github上的issue可以发现，有很多人都出现了类似问题，原因是EasyExcel最多支持创建64000个样式对象。但是我写入的数据远远超过了64000，每次写入数据都会去创建一次样式对象，导致生成excel失败。错误的代码如下： 1234567891011121314151617181920public class CustomCellWriteHandler implements CellWriteHandler &#123; /** * 设置拦截器顺序，需要 &gt; 50000 * * @return 拦截器顺序 */ @Override public int order() &#123; return 60000; &#125; @Override public void afterCellDispose(CellWriteHandlerContext context) &#123; Cell cell = context.getCell(); if (BooleanUtils.isNotTrue(context.getHead())) &#123; Workbook workbook = context.getWriteWorkbookHolder().getWorkbook(); // 此处代码有问题，每次进入条件，都会重复创建一个XSSFCellStyle对象 XSSFCellStyle cellStyle = (XSSFCellStyle) workbook.createCellStyle(); &#125;&#125; 解决此问题方法也比较简单，直接使用成员变量，不再重复创建对象。改造后的代码如下 123456789101112131415161718192021222324252627public class CustomCellWriteHandler implements CellWriteHandler &#123; XSSFCellStyle cellStyle; /** * 设置拦截器顺序，需要 &gt; 50000 * * @return 拦截器顺序 */ @Override public int order() &#123; return 60000; &#125; @Override public void afterCellDispose(CellWriteHandlerContext context) &#123; Cell cell = context.getCell(); if (BooleanUtils.isNotTrue(context.getHead())) &#123; Workbook workbook = context.getWriteWorkbookHolder().getWorkbook(); if (cellStyle == null) &#123; cellStyle = (XSSFCellStyle) workbook.createCellStyle(); &#125; cellStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND); &#125; &#125;&#125; 在创建新样式之前，判断下是不是已经有这个样式了，没有的话再创建，这样就避免了重复创建样式对象导致的异常。","categories":[],"tags":[{"name":"Java, EasyExcel","slug":"Java-EasyExcel","permalink":"https://linvaux.github.io/tags/Java-EasyExcel/"}]},{"title":"IDEA插件整理(一)","slug":"IDEA插件整理（一）","date":"2024-07-25T15:24:54.000Z","updated":"2024-07-25T15:38:47.895Z","comments":true,"path":"2024/07/25/IDEA插件整理（一）/","permalink":"https://linvaux.github.io/2024/07/25/IDEA%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"Atom Material Icons material风格图标库，装完之后页面就花里胡哨的，挺好看 Material Theme UI material风格主题，还是挺好看的 One Dark Theme 暗黑风格主题（推荐），主要是免费 Rainbow Brackets 彩虹括号 .ignore 生成各类.ignore文件，在创建git仓库的时候使用此插件格外方便 CodeGlance 代码缩略图，方便定位代码 Java Bean to Json 在bean上右键，即可将此bean复制为json格式，在构造请求时比较方便 maven-search maven&#x2F;gradle坐标搜索插件，贼好用，支持模糊搜索 Maven Helper 依赖冲突查看神器，也可以树状展示依赖关系 Mybatisx mybatis-plus团队出品的插件，支持从数据库表直接生成代码，包含基本CRUD功能，很方便 MyBatisCodeHelperPro 怎么说呢，就是很厉害，基本不用自己写代码了，但是收费 演示视频：https://www.bilibili.com/video/av50632948 使用文档：https://gejun123456.github.io/MyBatisCodeHelper-Pro/#/ MyBatis Log EasyPlus 格式化mybatis日志，很好用 SequenceDiagram 生成方法的时序图，非常有用官方文档：https://vanco.github.io/SequencePlugin/ PlantUML 时序图，类图绘制插件 Grep Console 由于Intellij idea不支持显示ascii颜色，grep-console插件能很好的解决这个问题，下面就以开发JavaEE项目中，结合Log4j配置多颜色日志输出功能。 GitToolBox git工具箱，可以显示当前代码分支和每一行代码提交人以及commit log Translation 翻译插件，再也不用去百度翻译了 RestfulToolkit 根据url直接跳转到对应的controller，比较好用，尤其是url多的时候，直接搜索url就可以了 Key promoter X 记性不好的可以试试，时间长了就能记住快捷键了 Statistic 项目信息统计 Git Commit Message Helper 帮助生成commit message","categories":[{"name":"工具分享","slug":"工具分享","permalink":"https://linvaux.github.io/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Java, IDEA","slug":"Java-IDEA","permalink":"https://linvaux.github.io/tags/Java-IDEA/"}]},{"title":"EasyExcel自定义字段导入","slug":"EasyExcel自定义字段导入","date":"2024-07-25T15:10:00.000Z","updated":"2024-07-25T15:10:32.847Z","comments":true,"path":"2024/07/25/EasyExcel自定义字段导入/","permalink":"https://linvaux.github.io/2024/07/25/EasyExcel%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E6%AE%B5%E5%AF%BC%E5%85%A5/","excerpt":"","text":"1.背景原先的导入功能只支持使用固定模板导入，模板格式如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Getter@Setter@ToStringpublic class TestCaseExcelData &#123; @ExcelProperty(value = &quot;所属功能模块&quot;) private String module; @ExcelProperty(value = &quot;用例编号&quot;) private String code; @NotBlank(message = &quot;必填项不能为空&quot;) @ExcelProperty(value = &quot;*用例名称&quot;) private String name; @NotBlank(message = &quot;必填项不能为空&quot;) @ExcelProperty(value = &quot;*优先级&quot;) private String caseLevel; @NotBlank(message = &quot;必填项不能为空&quot;) @ExcelProperty(value = &quot;*用例类型&quot;) private String caseType; @ExcelProperty(value = &quot;用例标签&quot;) private String tags; @ExcelProperty(value = &quot;前置条件&quot;) private String preSteps; @NotBlank(message = &quot;必填项不能为空&quot;) @ExcelProperty(value = &quot;*操作步骤/场景描述&quot;) private String stepDesc; @NotBlank(message = &quot;必填项不能为空&quot;) @ExcelProperty(value = &quot;*预期结果&quot;) private String expectResult; @ExcelProperty(value = &quot;关联需求类型&quot;) private String requirementType; @ExcelProperty(value = &quot;关联需求ID&quot;) private String requirementId; @ExcelProperty(value = &quot;用例版本&quot;) private String caseVersion;&#125; EasyExcel 导入监听器直接使用AnalysisEventListener 即可实现导入校验，校验规则较为复杂，不在此处展开。现在要求用户配置了自定义字段之后，还可以导入自定义字段，同时保留对固定字段的校验逻辑。因此原有的适用对象的监听器不再适用，需要使用无对象的方式做数据校验。 2.问题 EasyExcel 无对象方式的监听器是继承AnalysisEventListener&lt;Map&lt;Integer, String&gt;&gt;类，在重写了invoke() 方法后发现，入参是 Map&lt;Integer, String&gt; data，这就导致我无法对每一行数据按照原有的方式校验。 用户导入的模板列顺序是不固定的，因此也没法遍历 data 进行原有规则的校验。 3.解决方案3.1 解决思路 既然 invoke() 方法入参是 Map&lt;Integer, String&gt; data 这种数据结构，那能不能把这个 Map 中固定的字段转为一个 TestCaseExcelData 对象来处理？ 如果要转为一个对象，那怎么把 Map 中的数据跟对象的字段做映射？ 3.2 Map 转对象 Map&lt;Integer, String&gt; 是当前行的数据，其中 key 是当前行的列索引，value 是当前单元格的值，如果要转对象，首先得知道这个单元格对应的表头是什么，获取表头的方式很简单，直接在 listener 中定义一个 Map&lt;Integer, String&gt; headMap ,然后重写 invokeHeadMap(Map&lt;Integer, String&gt; headMap, AnalysisContext context) 方法，即可获取到表头。 取到表头之后，就可以在 invoke(Map&lt;Integer, String&gt; data, AnalysisContext context)方法中遍历data，根据此 map 的 key 来获取到当前单元格表头信息。代码如下：1234567@Overridepublic void invoke(Map&lt;Integer, String&gt; data, AnalysisContext context) &#123; data.forEach((index, value) -&gt; &#123; // 获取表头 String headName = headMap.get(index); &#125;); &#125; 取到了当前单元格的对应的表头之后，发现这个表头就是 TestCaseExcelData 类中属性上加的 @ExcelProperty(value &#x3D; “用例版本”) 注解中 value 属性的值，那就简单了，直接通过反射获取这个类所有表头和对应的属性，然后存到一个 Map&lt;Stirng, Field&gt; fieldStringMap 中就好了，这样就能通过表头获取到这个表头字段对应的类属性，为我们后面创建对象奠定了基础。代码如下：12345678Field[] fields = TestCaseExcelData.class.getDeclaredFields();for (Field field : fields) &#123; if (field.isAnnotationPresent(ExcelProperty.class)) &#123; ExcelProperty declaredAnnotation = field.getDeclaredAnnotation(ExcelProperty.class); String headValue = declaredAnnotation.value()[0]; this.fieldStringMap.put(headValue, field); &#125;&#125; 经过上面的几步操作，我们已经得到了如下的几个Map123456// 当前行的数据 &lt;列索引, 单元格值&gt;Map&lt;Integer, String&gt; data;// 表头的数据 &lt;列索引, 单元格值&gt;Map&lt;Integer, String&gt; headMap;// 实体对象表头和对应字段的数据 &lt;表头名称, 表头对应的属性&gt;Map&lt;Stirng, Field&gt; fieldStringMap; 后面的思路经很清晰了，遍历行数据Map&lt;Integer, String&gt; data ，通过 key 来确定当前单元格对应的表头，然后通过表头来获取实体类对应的属性，再通过反射来给这个属性赋值。代码如下：1234567891011121314151617181920212223242526272829303132@Overridepublic void invoke(Map&lt;Integer, String&gt; data, AnalysisContext context) &#123; // 创建实体对象 TestCaseExcelData rawData = new TestCaseExcelData(); try &#123; data.forEach((index, value) -&gt; &#123; // 获取到当前单元格的表头 String headName = headMap.get(index); // 根据表头获取实体类的属性 Field field = fieldStringMap.get(headName); try &#123; // 判断实体类是否有此属性 if (field != null) &#123; field.setAccessible(true); // 通过反射直接赋值 field.set(rawData, value); &#125; &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; // 解析自定义字段，只有系统配置的字段才会被缓存 List&lt;CustomFieldPO&gt; customFieldPOS = systemCustomFieldMap.get(headName); if (CollectionUtils.isNotEmpty(customFieldPOS)) &#123; customFieldMap.put(customFieldPOS.get(0).getFieldKey(), value); &#125; &#125;); // 固定字段校验 ExcelValidateHelper.validateEntity(rawData); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; &#125; 经过以上操作，我们成功的把一个 Map 转为了一个已知的对象，这样就跟通过对象导入一样了，后面校验的代码也无需再重复编写。 4. 其他最后，附上自定义模板校验表头的代码 12345678910111213141516171819@Overridepublic void invokeHeadMap(Map&lt;Integer, String&gt; headMap, AnalysisContext context) &#123; super.invokeHeadMap(headMap, context); // 限制文件行数不超过5000行 if (context.readSheetHolder().getApproximateTotalRowNumber() &gt; 5000) &#123; throw new ServiceException(CommonException.EXCEL_ROW_EXCEEDED); &#125; // 校验excel模版是否正确 ExcelImportUtil.validateHeadLoosely(headMap, this.dynamicCaseHeader.get(0)); this.headMap = headMap; Field[] fields = TestCaseExcelData.class.getDeclaredFields(); for (Field field : fields) &#123; if (field.isAnnotationPresent(ExcelProperty.class)) &#123; ExcelProperty declaredAnnotation = field.getDeclaredAnnotation(ExcelProperty.class); String headValue = declaredAnnotation.value()[0]; this.fieldStringMap.put(headValue, field); &#125; &#125; &#125; 1234567891011121314151617181920212223242526272829303132/** * 表头宽松校验 * &lt;p&gt;只校验表头是否存在模板中的字段&lt;/p&gt; * &lt;p&gt;不允许存在重复的表头&lt;/p&gt; * &lt;p&gt;导入文件中可以包含多余的列名&lt;/p&gt; * * @param headMap 实际读到的表头 * @param expectedHeadMapFiled 期望的表头 */public static void validateHeadLoosely(Map&lt;Integer, String&gt; headMap, List&lt;String&gt; expectedHeadMapFiled) &#123; try &#123; if (CollectionUtils.isEmpty(expectedHeadMapFiled) || MapUtils.isEmpty(headMap)) &#123; throw new ServiceException(CommonException.EXCEL_TEMPLATE_IS_NOT_CORRECT); &#125; // 移除没有内容的表头 headMap.entrySet().removeIf(entry -&gt; entry.getValue() == null); // 判断是否存在重复列 Collection&lt;String&gt; headValues = headMap.values(); Set&lt;String&gt; headValuesSet = new HashSet&lt;&gt;(headValues); if (headValues.size() != headValuesSet.size()) &#123; throw new ServiceException(CommonException.EXCEL_HEADS_DUPLICATED); &#125; // 判断模板字段是否都包含在表头里 for (String value : expectedHeadMapFiled) &#123; if (!headMap.containsValue(value)) &#123; throw new ServiceException(CommonException.EXCEL_TEMPLATE_IS_NOT_CORRECT); &#125; &#125; &#125; catch (Exception e) &#123; throw new ServiceException(&quot;Excel表头校验失败，异常详情：&quot; + ExceptionUtil.getErrorMessage(e)); &#125; &#125;","categories":[],"tags":[{"name":"Java, EasyExcel","slug":"Java-EasyExcel","permalink":"https://linvaux.github.io/tags/Java-EasyExcel/"}]},{"title":"EasyExcel自定义单元格样式","slug":"EasyExcel自定义单元格样式","date":"2024-07-25T15:09:03.000Z","updated":"2024-07-25T15:11:30.742Z","comments":true,"path":"2024/07/25/EasyExcel自定义单元格样式/","permalink":"https://linvaux.github.io/2024/07/25/EasyExcel%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%95%E5%85%83%E6%A0%BC%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"之前在开发系统的导出功能时需要对单元格增加不同的样式，过程有点曲折，记录一下以备后续用到 创建java项目，引入以下依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt; excel 导出代码 123456789101112131415try (ExcelWriter excelWriter = EasyExcel.write(filePath).build()) &#123; WriteSheet sheet = EasyExcel.writerSheet(&quot;自定义样式&quot;) // 设置表头 .head(ExportHeaderDTO.class) // 不使用默认样式 .useDefaultStyle(Boolean.FALSE) // 添加自定义单元格样式 .registerWriteHandler(new CustomCellWriteHandler()) // 添加单元格边框样式 .registerWriteHandler(CustomHorizontalCellStyleStrategy.cellBorder()) .build(); excelWriter.write(collect, sheet); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 自定义样式 CustomCellWriteHandler.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class CustomCellWriteHandler implements CellWriteHandler &#123; /** * 设置拦截器顺序，需要 &gt; 50000 * * @return 拦截器顺序 */ @Override public int order() &#123; return 60000; &#125; @Override public void afterCellDispose(CellWriteHandlerContext context) &#123; Cell cell = context.getCell(); if (BooleanUtils.isNotTrue(context.getHead())) &#123; Workbook workbook = context.getWriteWorkbookHolder().getWorkbook(); XSSFCellStyle cellStyle = (XSSFCellStyle) workbook.createCellStyle(); cellStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND); // 设置边框粗细 cellStyle.setBorderRight(BorderStyle.THIN); cellStyle.setBorderTop(BorderStyle.THIN); cellStyle.setBorderRight(BorderStyle.THIN); cellStyle.setBorderBottom(BorderStyle.THIN); // 设置边框颜色 cellStyle.setTopBorderColor(IndexedColors.BLACK.index); cellStyle.setBottomBorderColor(IndexedColors.BLACK.index); cellStyle.setLeftBorderColor(IndexedColors.BLACK.index); cellStyle.setRightBorderColor(IndexedColors.BLACK.index); cellStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND); // 水平居中 cellStyle.setAlignment(HorizontalAlignment.CENTER); // 垂直居中 cellStyle.setVerticalAlignment(VerticalAlignment.CENTER); Font font = workbook.createFont(); if (cell.getColumnIndex() == 1) &#123; // 设置字体颜色 font.setColor(IndexedColors.DARK_TEAL.index); cellStyle.setFont(font); // 设置单元格颜色 cellStyle.setFillForegroundColor(new XSSFColor(ColorConstant.CustomColor.PINK, CustomIndexedColorMap.fromColors(CTColors.Factory.newInstance()))); cell.setCellStyle(cellStyle); // 这里要把 WriteCellData的样式清空， 不然后面还有一个拦截器 FillStyleCellWriteHandler 默认会将 WriteCellStyle 设置到cell里面去 会导致自己设置的不一样（很关键） context.getFirstCellData().setWriteCellStyle(null); &#125; &#125; &#125;&#125; 边框样式 CustomHorizontalCellStyleStrategy.java 12345678910111213141516171819202122232425public class CustomHorizontalCellStyleStrategy extends HorizontalCellStyleStrategy &#123; @Override public int order() &#123; return 6500; &#125; /** * 设置单元格边框 * @return 样式策略 */ public static HorizontalCellStyleStrategy cellBorder() &#123; WriteCellStyle headWriteCellStyle = new WriteCellStyle(); headWriteCellStyle.setTopBorderColor(IndexedColors.BLACK.index); headWriteCellStyle.setBottomBorderColor(IndexedColors.BLACK.index); headWriteCellStyle.setLeftBorderColor(IndexedColors.BLACK.index); headWriteCellStyle.setRightBorderColor(IndexedColors.BLACK.index); headWriteCellStyle.setFillPatternType(FillPatternType.SOLID_FOREGROUND); WriteCellStyle contentWriteCellStyle = new WriteCellStyle(); contentWriteCellStyle.setBorderRight(BorderStyle.THIN); contentWriteCellStyle.setBorderTop(BorderStyle.THIN); contentWriteCellStyle.setBorderRight(BorderStyle.THIN); contentWriteCellStyle.setBorderBottom(BorderStyle.THIN); return new HorizontalCellStyleStrategy(headWriteCellStyle, contentWriteCellStyle); &#125;&#125;","categories":[],"tags":[{"name":"Java, EasyExcel","slug":"Java-EasyExcel","permalink":"https://linvaux.github.io/tags/Java-EasyExcel/"}]},{"title":"基于Centos7的UI自动化环境Dockerfile","slug":"基于Centos7的UI自动化环境Dockerfile","date":"2024-07-25T15:08:06.000Z","updated":"2024-07-25T15:08:31.205Z","comments":true,"path":"2024/07/25/基于Centos7的UI自动化环境Dockerfile/","permalink":"https://linvaux.github.io/2024/07/25/%E5%9F%BA%E4%BA%8ECentos7%E7%9A%84UI%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83Dockerfile/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657FROM centos:7MAINTAINER linvaux &lt;linvaux@outlook.com&gt;WORKDIR /opt# 修改源，安装依赖RUN sed -i &quot;s/#baseurl/baseurl/g&quot; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\ sed -i &quot;s/mirrorlist=http/#mirrorlist=http/g&quot; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\ sed -i &quot;s@http://mirror.centos.org@https://repo.huaweicloud.com@g&quot; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\ yum clean all &amp;&amp; \\ yum makecache &amp;&amp; \\ yum update -y &amp;&amp; \\ yum install -y wget git zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc make# 安装JDK1.8RUN wget http://10.177.248.111:8089/ftp/dev_tools/jdk-8u271-linux-x64.tar.gz &amp;&amp; \\ tar -vxf jdk-8u271-linux-x64.tar.gz &amp;&amp; \\ mv jdk1.8.0_271/ /usr/local/ &amp;&amp; \\ echo &#x27;export JAVA_HOME=/usr/local/jdk1.8.0_271&#x27; &gt;&gt; /etc/profile &amp;&amp; \\ echo &#x27;export JRE_HOME=$&#123;JAVA_HOME&#125;/jre&#x27; &gt;&gt; /etc/profile &amp;&amp; \\ echo &#x27;export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib&#x27; &gt;&gt; /etc/profile &amp;&amp; \\ echo &#x27;export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH&#x27; &gt;&gt; /etc/profile echo `java -version`# 安装python3.7RUN wget https://mirrors.huaweicloud.com/python/3.7.8/Python-3.7.8.tgz &amp;&amp; \\ tar -vxf Python-3.7.8.tgz &amp;&amp; \\ mv Python-3.7.8 /usr/local/python378 &amp;&amp; \\ cd /usr/local/python378 &amp;&amp; \\ ./configure --prefix=/usr/local/python378 --enable-loadable-sqlite-extensions --with-ssl &amp;&amp;\\ make -j$(nproc) &amp;&amp; \\ make install -j$(nproc) &amp;&amp; \\ ln -s /usr/local/python378/bin/python3.7 /usr/bin/python3 &amp;&amp; \\ ln -s /usr/local/python378/bin/pip3 /usr/bin/pip3 &amp;&amp; \\ mkdir /root/.pip &amp;&amp; \\ echo &quot;[global]&quot; &gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;index-url=https://pypi.douban.com/simple/&quot; &gt;&gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;[install]&quot; &gt;&gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;trusted-host=pypi.douban.com&quot; &gt;&gt; /root/.pip/pip.conf echo `python3 -V`# 安装chromeRUN echo &#x27;[google-chrome]&#x27; &gt; /etc/yum.repos.d/google-chrome.repo &amp;&amp; \\ echo &#x27;name=google-chrome&#x27; &gt;&gt; /etc/yum.repos.d/google-chrome.repo &amp;&amp; \\ echo &#x27;baseurl=http://dl.google.com/linux/chrome/rpm/stable/$basearch&#x27; &gt;&gt; /etc/yum.repos.d/google-chrome.repo &amp;&amp; \\ echo &#x27;enabled=1&#x27; &gt;&gt; /etc/yum.repos.d/google-chrome.repo &amp;&amp; \\ echo &#x27;gpgcheck=1&#x27; &gt;&gt; /etc/yum.repos.d/google-chrome.repo &amp;&amp; \\ echo &#x27;gpgkey=https://dl-ssl.google.com/linux/linux_signing_key.pub&#x27; &gt;&gt; /etc/yum.repos.d/google-chrome.repo &amp;&amp; \\ yum -y install google-chrome-stable --nogpgcheck &amp;&amp; \\ echo `google-chrome --version`# 安装chromedriver驱动# 安装allureRUN rm -rf jdk-8u271-linux-x64.tar.gz &amp;&amp; \\ rm -rf Python-3.7.8.tgz &amp;&amp; \\ yum clean all","categories":[],"tags":[{"name":"Docker, 自动化测试","slug":"Docker-自动化测试","permalink":"https://linvaux.github.io/tags/Docker-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"}]},{"title":"基于Centos7的Python3.7镜像构建","slug":"基于Centos7的Python3-7镜像构建","date":"2024-07-25T15:07:16.000Z","updated":"2024-07-25T15:07:40.904Z","comments":true,"path":"2024/07/25/基于Centos7的Python3-7镜像构建/","permalink":"https://linvaux.github.io/2024/07/25/%E5%9F%BA%E4%BA%8ECentos7%E7%9A%84Python3-7%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA/","excerpt":"","text":"Dockerfile123456789101112131415161718192021222324252627282930FROM centos:7MAINTAINER linvaux &lt;linvaux@outlook.com&gt;WORKDIR /optRUN sed -i &quot;s/#baseurl/baseurl/g&quot; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\ sed -i &quot;s/mirrorlist=http/#mirrorlist=http/g&quot; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\ sed -i &quot;s@http://mirror.centos.org@https://repo.huaweicloud.com@g&quot; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\ yum clean all &amp;&amp; \\ yum makecache &amp;&amp; \\ yum update -yRUN yum install -y wget zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc makeRUN wget https://mirrors.huaweicloud.com/python/3.7.8/Python-3.7.8.tgz &amp;&amp; \\ tar -vxf Python-3.7.8.tgz &amp;&amp; \\ mv Python-3.7.8 /usr/local/python378 &amp;&amp; \\ cd /usr/local/python378 &amp;&amp; \\ ./configure --prefix=/usr/local/python378 --enable-loadable-sqlite-extensions --with-ssl &amp;&amp;\\ make -j$(nproc) &amp;&amp; \\ make install -j$(nproc) &amp;&amp; \\ ln -s /usr/local/python378/bin/python3.7 /usr/bin/python3 &amp;&amp; \\ ln -s /usr/local/python378/bin/pip3 /usr/bin/pip3 &amp;&amp; \\ mkdir /root/.pip &amp;&amp; \\ echo &quot;[global]&quot; &gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;index-url=https://pypi.douban.com/simple/&quot; &gt;&gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;[install]&quot; &gt;&gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;trusted-host=pypi.douban.com&quot; &gt;&gt; /root/.pip/pip.confRUN rm -rf Python-3.7.8.tgz 构建命令1docker build -t centos-python378 .","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://linvaux.github.io/tags/Docker/"}]},{"title":"基于Ubuntu16.04的Python3.7镜像构建","slug":"基于Ubuntu16-04的Python3-7镜像构建","date":"2024-07-25T15:06:21.000Z","updated":"2024-07-25T15:06:40.594Z","comments":true,"path":"2024/07/25/基于Ubuntu16-04的Python3-7镜像构建/","permalink":"https://linvaux.github.io/2024/07/25/%E5%9F%BA%E4%BA%8EUbuntu16-04%E7%9A%84Python3-7%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA/","excerpt":"","text":"Dockerfile12345678910111213141516171819202122232425262728FROM ubuntu:16.04MAINTAINER linvaux &lt;linvaux@outlook.com&gt;WORKDIR /optRUN sed -i &quot;s@http://.*archive.ubuntu.com@http://repo.huaweicloud.com@g&quot; /etc/apt/sources.list &amp;&amp; \\ sed -i &quot;s@http://.*security.ubuntu.com@http://repo.huaweicloud.com@g&quot; /etc/apt/sources.list &amp;&amp; \\ apt-get update &amp;&amp; \\ apt-get upgrade -yRUN apt-get install -y gcc make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev xz-utils tk-dev libffi-dev liblzma-devRUN wget https://mirrors.huaweicloud.com/python/3.7.8/Python-3.7.8.tgz &amp;&amp; \\ tar -vxf Python-3.7.8.tgz &amp;&amp; \\ mv Python-3.7.8 /usr/local/python378 &amp;&amp; \\ cd /usr/local/python378 &amp;&amp; \\ ./configure --prefix=/usr/local/python378 --enable-loadable-sqlite-extensions --with-ssl &amp;&amp;\\ make -j$(nproc) &amp;&amp; \\ make install -j$(nproc) &amp;&amp; \\ ln -s /usr/local/python378/bin/python3.7 /usr/bin/python3 &amp;&amp; \\ ln -s /usr/local/python378/bin/pip3 /usr/bin/pip3 &amp;&amp; \\ mkdir /root/.pip &amp;&amp; \\ echo &quot;[global]&quot; &gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;index-url=https://pypi.douban.com/simple/&quot; &gt;&gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;[install]&quot; &gt;&gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;trusted-host=pypi.douban.com&quot; &gt;&gt; /root/.pip/pip.confRUN rm -rf Python-3.7.8.tgz 构建命令1docker build -t ubuntu-python378 .","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://linvaux.github.io/tags/Docker/"}]},{"title":"CentOS安装Google-Chrome浏览器","slug":"CentOS安装Google-Chrome浏览器","date":"2024-07-25T15:05:23.000Z","updated":"2024-07-25T15:06:01.769Z","comments":true,"path":"2024/07/25/CentOS安装Google-Chrome浏览器/","permalink":"https://linvaux.github.io/2024/07/25/CentOS%E5%AE%89%E8%A3%85Google-Chrome%E6%B5%8F%E8%A7%88%E5%99%A8/","excerpt":"","text":"配置yum源 在目录 &#x2F;etc&#x2F;yum.repos.d&#x2F; 下新建文件 google-chrome.repo 1vim /etc/yum.repos.d/google-chrome.repo 添加如下内容 123456[google-chrome]name=google-chromebaseurl=http://dl.google.com/linux/chrome/rpm/stable/$basearchenabled=1gpgcheck=1gpgkey=https://dl-ssl.google.com/linux/linux_signing_key.pub 安装google chrome浏览器及chromedriver Google官方源安装： 12yum makecacheyum -y install google-chrome-stable Google官方源可能在中国无法使用，导致安装失败或者在国内无法更新，可以添加以下参数来安装： 1yum -y install google-chrome-stable --nogpgcheck 检查chrome版本 1google-chrome --version 下载对应版本的的chromedriver 检查chromedriver版本 1chromedriver --version","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://linvaux.github.io/tags/Docker/"}]},{"title":"Mac使用Jenv实现Jdk多版本管理","slug":"Mac使用Jenv实现Jdk多版本管理","date":"2024-07-25T14:53:58.000Z","updated":"2024-07-25T15:00:39.446Z","comments":true,"path":"2024/07/25/Mac使用Jenv实现Jdk多版本管理/","permalink":"https://linvaux.github.io/2024/07/25/Mac%E4%BD%BF%E7%94%A8Jenv%E5%AE%9E%E7%8E%B0Jdk%E5%A4%9A%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/","excerpt":"","text":"前言目前在开发过程中，需要同时安装 Jdk8, Jdk11, Jdk17 进行项目开发，为了统一管理Jdk 环境，需要一款类似 conda 的工具来管理多套 Jdk 环境，可选的方案有以下几种： 使用 shell 脚本来动态设置 JAVA_HOME； 使用 scoop 来管理环境； 使用 jenv 来管理环境； 经过使用体验，最后选择了 jenv 来做 jdk 版本管理。 安装在 mac 下面可以使用 brew 来安装 jenv 1brew install jenv 我用的 zsh，因此还需要将 jenv 添加到 zsh 中 123echo &#x27;export PATH=&quot;$HOME/.jenv/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc# 执行 jenv 初始化脚本，类似于 conda init 命令echo &#x27;eval &quot;$(jenv init -)&quot;&#x27; &gt;&gt; ~/.zshrc 配置1.添加在本地已经安装的 jdk123jenv add /Library/Java/JavaVirtualMachines/jdk-17.0.5.jdk/Contents/Home/jenv add /Library/Java/JavaVirtualMachines/jdk1.8.0_301.jdk/Contents/Home/jenv add /Library/Java/JavaVirtualMachines/jdk-11.0.11.jdk/Contents/Home/ 2.列出已经添加的 jdk 版本1jenv versions 3.设置 jdk 的三种方式 jenv local ：该命令将会在当前目录下设置特定的 Java 版本。这意味着只有在该目录下执行程序调用时才会使用该版本的 Java。 jenv global ：该命令将会设置系统全局的 Java 版本。当在终端或其它地方运行 Java 应用程序时，都将使用该版本的 Java。 jenv shell ：该命令将会在当前 Shell 会话中设置特定的 Java 版本。这意味着只有在该 Shell 会话中执行程序调用时才会使用该版本的 Java。 因此，这三个命令的主要区别在于设置 Java 版本的作用域和范围。jenv local 的作用域仅限于当前工作目录，jenv global 的作用域与操作系统全局环境相关，而 jenv shell 的作用域仅限于当前 Shell 会话。因此，根据具体情况选择使用不同的命令。需要注意的是，jenv 只对使用 jenv exec 执行的命令生效，对于直接使用 java 命令执行的程序，jenv 并不会自动切换 Java 版本。因此，需要手动设置系统环境变量或使用别的工具来切换 Java 版本。 4.Jenv 诊断jenv doctor 是 jenv 命令行工具提供的一个诊断工具，用于检查本地系统的 Java 环境是否正确配置。当我们安装 jenv 后，需要将其配置到系统环境变量中，并安装所需的 Java 版本。使用 jenv doctor 命令可以检测配置和 Java 版本是否正确安装，并提供诊断信息和建议以解决检测出的问题。jenv doctor 常见的使用场景有： 检查 jenv 的环境变量是否正确配置。jenv 是一款基于环境变量来管理多个 Java 版本的工具，因此我们需要将其配置到系统环境变量中，并确保环境变量的正确性。 检查 jenv 的安装路径和版本号。检查 jenv 实际安装的位置以及当前所用的版本号，是否符合预期要求。 检查可用的 Java 版本是否正确安装和配置。jenv doctor 会检查本地系统环境中已经安装的 Java 版本，是否安装在了 jenv 管理的目录中，并支持在 jenv 中进行切换。 参考文档 Jenv 官方文档","categories":[{"name":"工具分享","slug":"工具分享","permalink":"https://linvaux.github.io/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Mac, JDK","slug":"Mac-JDK","permalink":"https://linvaux.github.io/tags/Mac-JDK/"}]},{"title":"Pytest参数","slug":"Pytest参数","date":"2024-07-25T14:40:14.000Z","updated":"2024-07-25T14:40:51.371Z","comments":true,"path":"2024/07/25/Pytest参数/","permalink":"https://linvaux.github.io/2024/07/25/Pytest%E5%8F%82%E6%95%B0/","excerpt":"","text":"分类 参数 作用 general -k 支持python的表达式，用于筛选指定标记&#x2F;方法名的用例 -m 根据用例标签来筛选用例，设置标签可以使用 @pytest.mark.&lt;标签名&gt; –markers 打印标签，包括内置的，插件的，还有自定义的 -x 第一个error或failed的test就退出 –fixtures 显示可用的fixture，包括内置和自己写的，如果fixture使用 “_”开头则需要使用-v才能显示此fixture –fixtures-per-test 展示每条用例的fixture –pdb 当用例出现错误或者被键盘中断后，启动pdb调试 –pdbcls&#x3D;modulename:classname 启动自定义pdb debugger，一般用不到这个 –trace 执行测试用例时break，进入debugger –capture&#x3D;method 标准输出&#x2F;标准错误输出&#x2F;标准输入的默认捕获，fd：标准输入，标准错误输出都会捕获；sys：只有向Python的sys.stdout和sys.stderr的写入行为会被捕获，不执行对文件描述符的写入的捕获；no：对print语句内容捕获，等同于 -s -s 显示print语句的内容 –runxfail 强制运行xfail标记的用例 –lf, –last-failed 重新执行上次测试执行失败的用例，如果没有失败的用例，则执行全部用例 –ff, –failed-first 优先跑上次失败的test，tests的顺序会被打乱 –nf, –new-first 优先跑新添加的tests，剩余的按文件mtime顺序 –cache-show&#x3D;[CACHESHOW] 显示缓存，默认 * 显示所有缓存，可以带参数 pytest –cache-show&#x3D;cache&#x2F;nodeids –cache-clear 在执行用例前，清理pytest缓存 –lfnf&#x3D;{all,none}, –last-failed-no-failures&#x3D;{all,none} 没有last-failed缓存数据，或上次没有失败时，执行全部用例 –sw, –stepwise 逐步运行，在失败时退出，下次运行时从失败的用例开始 –stepwise-skip 跳过第一个失败的test，如果再遇到失败就退出 reporting –durations&#x3D;N 显示N个最慢的setup&#x2F;test的耗时，N&#x3D;0时，显示所有耗时 –durations-min&#x3D;N 显示N个最小的setup&#x2F;test的耗时 -v, –verbose 输出详细信息 –no-header 不显示pytest消息头，只展示用例信息 –no-summary 不显示用例执行完的summary info -q, –quiet 静默模式，不输出任何内容 –verbosity&#x3D;VERBOSE 信息显示等级，貌似没啥用 -r chars -r f：显示failed信息；-r E：显示error信息；-r s：显示skipped信息；-r x：显示xfailed信息；-r X：显示xpassed信息；-r p：显示passed信息；-r P：显示 passed with output信息； -r a&#x2F;A：显示 all except passed信息；-r w：显示默认告警信息；-r N：重置list –disable-warnings, –disable-pytest-warnings 禁用pytest告警，如未注册的标记等 -l, –showlocal 用例执行失败时，打印堆栈信息，默认被禁用 –tb&#x3D;style traceback打印模式，一般设置为auto即可 –show-capture&#x3D;{no,stdout,stderr,log,all} 失败的用例如何显示，默认为all –full-trace 不截取traceback，默认会截断 –color&#x3D;color 是否显示彩色，yes：显示颜色；no：不显示颜色；auto：自动 –code-highlight&#x3D;{yes,no} 代码是否高亮显示，一般用不到 –pastebin&#x3D;mode 没什么用的参数，我也不知道干嘛的 –junit-xml&#x3D;path 在给定的path路径下生成junit-xml风格的测试报告 –junit-prefix&#x3D;str 在junit-xml输出中的classnames添加前缀 pytest-warnings -W PYTHONWARNINGS, –pythonwarnings&#x3D;PYTHONWARNINGS 设置报告哪些warnings –maxfail&#x3D;num 出现num个errors或者fails就退出测试 –strict-config 解析配置文件中pytest部分时，遇到warning就抛出error –strict-markers, –strict 发现未知标记时，抛出error， -c file 从指定配置文件加载配置，默认为pytes.ini –continue-on-collection-errors 在收集用例时发生错误，也会继续执行用例 –rootdir&#x3D;ROOTDIR tests根目录，相对路径 collection –collect-only, –co 收集用例，但不执行 –pyargs 把所有参数解释为python包 –ignore&#x3D;path 忽略测试目录，使用英文逗号分割 –ignore-glob&#x3D;path path匹配多个不需要收集的测试目录，使用英文逗号分割 –deselect&#x3D;nodeid_prefix 通过node id prefix反选。可以多个，使用英文逗号分隔 –confcutdir&#x3D;dir 只加载相对于dir目录的conftest.py文件 –noconftest 不加载conftest.py文件 –keep-duplicates 收集重复的test文件，默认只会收集1item，加参数后会收集2items –collect-in-virtualenv 收集本地虚拟环境目录的tests –import-mode&#x3D;{prepend,append,importlib} 包导入模式，一般用不到，参考：https://www.osgeo.cn/pytest/pythonpath.html?highlight=import%20mode –doctest-modules 文档测试，没啥用 –doctest-report&#x3D;{none,cdiff,ndiff,udiff,only_first_failure} 一样，也没啥用 –doctest-glob&#x3D;pat 还是没啥用 –doctest-ignore-import-errors 文档测试时忽略导包错误，继续没什么用 –doctest-continue-on-failure 文档测试时出现失败继续测试，依然没什么用 test session debugging and configuration –basetemp&#x3D;dir test run的base临时目录（如果存在会先删除） -V, –version 输出pytest版本 -h, –help 打印pytest帮助信息 -p name 加载插件，一般不会控制此参数 –trace-config 查看本地安装好的第三方插件 –debug 保存debug信息到’pytestdebug.log’文件 -o OVERRIDE_INI, –override-ini&#x3D;OVERRIDE_INI 覆盖ini文件配置 –assert&#x3D;MODE 断言模式，默认rewrite –setup-only 只加载fixture，不执行测试用例 –setup-show 在执行测试用例时，打印fixture步骤 –setup-plan 展示哪些用例和fixture将要被执行 logging –log-level&#x3D;LEVEL 日志等级，默认 WARNING （具体日志等级参考 logging 模块中的日志等级） –log-format&#x3D;LOG_FORMAT 日志格式（具体日志格式参考 logging 模块中的日志格式） –log-date-format&#x3D;LOG_DATE_FORMA 日志日期格式（具体日志格式参考 logging 模块中的日志格式） –log-cli-level&#x3D;LOG_CLI_LEVEL cli日志等级（具体日志等级参考 logging 模块中的日志等级） –log-cli-format&#x3D;LOG_CLI_FORMAT cli日志格式（具体日志格式参考 logging 模块中的日志格式） –log-cli-date-format&#x3D;LOG_CLI_DATE_FORMAT cli日志日期格式（具体日志格式参考 logging 模块中的日志格式） –log-file&#x3D;LOG_FILE 日志文件路径 –log-file-level&#x3D;LOG_FILE_LEVE 日志文件中的日志等级 –log-file-format&#x3D;LOG_FILE_FORMAT 日志文件中的日志格式 –log-file-date-format&#x3D;LOG_FILE_DATE_FORMAT 日志文件中的日志时间格式 –log-auto-indent&#x3D;LOG_AUTO_INDENT 自动缩进传递给日志模块的多行消息。接受true | on、false | off或整数","categories":[{"name":"测试","slug":"测试","permalink":"https://linvaux.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"Pytest","slug":"Pytest","permalink":"https://linvaux.github.io/tags/Pytest/"}]}],"categories":[{"name":"工具分享","slug":"工具分享","permalink":"https://linvaux.github.io/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"},{"name":"测试","slug":"测试","permalink":"https://linvaux.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linvaux.github.io/tags/Java/"},{"name":"IDEA","slug":"IDEA","permalink":"https://linvaux.github.io/tags/IDEA/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://linvaux.github.io/tags/Jenkins/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://linvaux.github.io/tags/SpringBoot/"},{"name":"LogStash","slug":"LogStash","permalink":"https://linvaux.github.io/tags/LogStash/"},{"name":"Java, EasyExcel","slug":"Java-EasyExcel","permalink":"https://linvaux.github.io/tags/Java-EasyExcel/"},{"name":"Java, IDEA","slug":"Java-IDEA","permalink":"https://linvaux.github.io/tags/Java-IDEA/"},{"name":"Docker, 自动化测试","slug":"Docker-自动化测试","permalink":"https://linvaux.github.io/tags/Docker-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"Docker","slug":"Docker","permalink":"https://linvaux.github.io/tags/Docker/"},{"name":"Mac, JDK","slug":"Mac-JDK","permalink":"https://linvaux.github.io/tags/Mac-JDK/"},{"name":"Pytest","slug":"Pytest","permalink":"https://linvaux.github.io/tags/Pytest/"}]}