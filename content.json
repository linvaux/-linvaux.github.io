{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://linvaux.github.io","root":"/"},"pages":[{"title":"categories","date":"2024-07-25T14:43:59.000Z","updated":"2024-07-25T14:43:59.465Z","comments":true,"path":"categories/index.html","permalink":"https://linvaux.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2024-07-25T14:43:48.000Z","updated":"2024-07-25T14:43:48.484Z","comments":true,"path":"tags/index.html","permalink":"https://linvaux.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java中的异常处理","slug":"Java中的异常处理","date":"2024-07-26T14:37:04.000Z","updated":"2024-07-26T14:49:47.622Z","comments":true,"path":"2024/07/26/Java中的异常处理/","permalink":"https://linvaux.github.io/2024/07/26/Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"1. Java 中的异常分类Java中的异常类均以Throwable为父类，而Throwable又派生出 Error 和 Exception 两类，区别如下 1.1 Error类及其子类代表了JVM自身的异常。这一类异常发生时，无法通过程序来修正。例如系统崩溃、内存溢出等。与异常不同，错误表示程序无法继续执行下去，一般不需要进行捕获或处理。错误通常是由底层系统或环境导致的，它们是不可控的，最可靠的方式就是尽快地停止JVM的运行。 1.2 Exception类及其子类Exception又分为运行时异常(RuntimeException)和非运行时异常， 这两种异常有很大的区别，也称之为非受检异常（Unchecked Exception）和受检异常（Checked Exception），其中Error类及其子类也是非受检异常。 受检异常：也称为“编译时异常”，编译器在编译期间检查的那些异常。由于编译器“检查”这些异常以确保它们得到处理，因此称为“检查异常”。如果抛出检查异常，那么编译器会报错，需要开发人员手动处理该异常，要么捕获，要么重新抛出。除了RuntimeException之外，所有直接继承 Exception 的异常都是检查异常。 非受检异常：也称为“运行时异常”，编译器不会检查运行时异常，在抛出运行时异常时编译器不会报错，当运行程序的时候才可能抛出该异常。Error及其子类和RuntimeException 及其子类都是非检查异常。 Java 中异常类的关系可以使用如下 UML 类图表示 受检异常和非受检异常是针对编译器而言的，是编译器来检查该异常是否强制开发人员处理该异常： 受检异常导致异常在方法调用链上显式传递，而且一旦底层接口的检查异常声明发生变化，会导致整个调用链代码更改。 使用非受检异常不会影响方法签名，而且调用方可以自由决定何时何地捕获和处理异常。 1.3 受检异常举例 编译器提示需要处理这个异常，这种异常处理有两种方式： 在方法签名上抛出此异常，由方法调用方处理 使用try-catch 捕获异常，内部处理 1.4 非受检异常异常举例所有继承 RuntimeException 的异常都是非检查异常，直接抛出非检查异常编译器不会提示错误 方法直接抛出 RuntimeException 时，编译器并不会要求捕获或者抛出此异常。 2. try-catchtry-catch 关键字在Java 中主要用于捕获异常，并进行处理。简单示例如下： 在 try{} 代码块中，是可能抛出异常的代码或者调用了签名上会抛出异常的方法。cath{} 代码块中则是捕获异常，并处理异常。注意：catch 可以捕获多种异常，并根据异常种类不同，分开处理，但是要注意异常捕获的顺序。 在上面的示例中，先捕获了 IOException，IDE 就会提示下面的 FileNotFoundException 无需再被捕获了，因为 IOException 是 FileNotFoundException 的父类，捕获到 IOException 之后，其所有子类的异常捕获代码都会失效。 下面演示如何同时捕获多个异常，并用同一个分支处理： 当我们需要对多个异常分组处理时，可以使用 catch(Exception1 | Exception2 e) 来捕获多个异常。 3. try-catch-finallytry-catch-finally 用于在处理异常时，不管是否发生异常，都要执行的操作。示例代码如下： try 代码块中发生了异常： 提问：为什么先打印了 finally 代码块中的内容，后打印了异常信息？ try 代码块未异常： finally{} 一般用于资源的关闭，或者数据的清理， 但是也可以在 finally 中执行 return 命令来修改方法返回。示例代码如下： 提问：大家觉得这个cal 方法返回值是多少？为什么？ 正常情况下，finally 代码块中的代码一定是会执行的，但是也有以下几种失效情况： 在执行 try 或 catch 块之前 JVM 被非法终止，比如程序正在运行，但是使用 pkill -9 java 命令强行停止 Java 进程。 在 try 或 catch 块中发生了 System.exit() 调用，导致 JVM 直接退出。 在 try 或 catch 块中发生了死循环，导致程序无法继续执行。 在 try 或 catch 块中发生了栈溢出异常（StackOverflowError）或虚拟机异常（如 OutOfMemoryError），导致 JVM 崩溃。 程序所在的线程被强制中断或程序进程被操作系统杀死。 在 try 或 catch 块中使用了 System.halt() 方法，显式终止 JVM。 调用了 native 方法，而该方法中不包含 finally 块。 4. try-with-resources 用法try-with-resources 是 Java 7 引入的一个语法结构，用于更加方便地处理需要关闭的资源。它可以自动关闭实现了 AutoCloseable 或 Closeable 接口的资源，无需手动编写 finally 块来关闭资源。try-with-resources 的语法形式是在 try 关键字之后使用圆括号括起来的资源声明列表。每个资源在括号中声明并初始化。当 try 块结束时，无论是否发生异常，这些资源都将自动关闭，而不需要显式调用 close() 方法。以下是一个读取文件并自动关闭流的示例： FileInputStream 之所以可以自动关闭，是因为其继承了 InputStream 类，而InputStream类实现了 Closeable 接口，FileInputStream重写了 close()方法，以下是具体实现： 那如何证明使用 try-with-resources 时，close 方法真的被调用了呢？我们可以使用如下命令编译 App.java 文件，并看下生成的字节码文件 12# -g 参数用于生成与调试相关的信息，包括调试符号和源代码行号。它允许在编译后的字节码中插入调试信息，以便在调试过程中可以精确地映射回源代码的行号和变量名javac -g App.java 生成的 class 文件如下： 从上面的 class 文件中我们可以清楚看到 jvm 帮我们生成了一个 catch 代码块，用来捕获外层 try 代码块可能抛出的异常，并且在 catch 代码块中显式调用了 fis 的 close() 方法进行资源关闭。这就是为什么说 无论是否发生异常，这些资源都将自动关闭。 5. 异常处理规范异常处理规范参考 《阿里巴巴代码开发规范》 中的约束。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://linvaux.github.io/tags/Java/"}]},{"title":"深入理解Java中的序列化和反序列化","slug":"深入理解Java中的序列化和反序列化","date":"2024-07-26T14:14:54.000Z","updated":"2024-07-26T14:36:17.165Z","comments":true,"path":"2024/07/26/深入理解Java中的序列化和反序列化/","permalink":"https://linvaux.github.io/2024/07/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"1. 技术背景​ 互联网的迅猛发展受益于网络通信技术的成熟和稳定。网络通信协议是机器双方共同约定的协议。在应用层看到的是结构体、对象，但是在网络协议里，机器之间传输的都是二进制流。网络编程中，需要定义应用层协议。最原始的应用层协议是字节数组，在 Java 语言里以 byte［］体现，在C语言里以 char［］体现。不管是 Java 语言还是 C 语言，开发人员都需要知道字节数组里每个字节的含义才能保证数据写入和读取的正确性。这对开发人员来说，是非常严苛且低效的。如何将程序中的结构体、对象等结构化内存对象转换为扁平的二进制流？如何将二进制流还原为结构化内存对象？为了解决这些问题，序列化&#x2F;反序列化技术应运而生。 核心意义：对象状态的保存(序列化)和重建(反序列化) 2. 序列化协议的特性 通用性 技术层面，序列化协议是否支持跨平台、跨语言。如果不支持，在技术层面上的通用性就大大降低了。 流行程度，社区是否成熟，是否能及时跟进Issue并解决Bug。 鲁棒性 成熟度不够，一个协议从制定到实施，到最后成熟往往是一个漫长的阶段。协议的强健性依赖于大量而全面的测试，对于致力于提供高质量服务的系统，采用处于测试阶段的序列化协议会带来很高的风险。 语言&#x2F;平台的不公平性。为了支持跨语言、跨平台的功能，序列化协议的制定者需要做大量的工作；但是，当所支持的语言或者平台之间存在难以调和的特性的时候，协议制定者需要做一个艰难的决定–支持更多人使用的语言&#x2F;平台，亦或支持更多的语言&#x2F;平台而放弃某个特性。当协议的制定者决定为某种语言或平台提供更多支持的时候，对于使用者而言，协议的强健性就被牺牲了。 可扩展性&#x2F;兼容性 扩展性表现为随着业务需求变化需要增减字段。字段变化的过程中，不会对现有系统的数据存储、数据访问造成影响，具有向后兼容性。扩展性也是序列化&#x2F;反序列化技术的核心指标之一。 性能 时间开销，复杂的序列化协议会导致较长的解析时间，这可能会使得序列化和反序列化阶段成为整个系统的瓶颈。 空间开销，如果序列化过程引入的额外开销过高，可能会导致过大的网络，磁盘等各方面的压力。对于海量分布式存储系统，数据量往往以TB为单位，巨大的的额外空间开销意味着高昂的成本。 易用性 易用性决定了开发者是不是需要花很多时间去学习，门槛是不是很高，接口是不是容易理解和使用。 安全性 安全性也是序列化工具选型的重要参考意见，比如广泛使用的fastjson，很多版本都存在RCE漏洞。 3. 序列化引擎​ 一般来说，序列化&#x2F;反序列化分为IDL（Interface Description Language，接口描述语言）和非IDL两类。非IDL技术方案包含 JSON、XML等，提供构造和解析的工具包即可使用，不需要做代码生成的工作。IDL技术方案包含 Thrift、Protocol Buffer、Avro 等，有比较完整的规约和框架实现。 IDL 描述文件：比如，Thrift 是以 thrift 为后缀的文件，Protocol Buffer是以 proto 为后缀的文件。IDL 文件编译器：根据 IDL 文件生成具有序列化&#x2F;反序列化功能的代码文件。例如，Thrift 通过 thrift 命令行指定编程语言类型来生成代码文件，Protocol Buffer 根据 protoc 命令行生成代码文件。Stub&#x2F;Skeleton 代码：在客户（Client）端，一般称为 Stub 代码。在服务器（Server）端，一般称为 Skeleton 代码。 4. Java序列化方式4.1 实现Serializable接口4.1.1 默认的序列化&#x2F;反序列化实现 Serializable 接口是最常用的序列化方式，以下是简单示例 准备一个待序列化的对象 12345678910111213141516package com.wick.pojo;import lombok.*;import java.io.Serializable;@Getter@Setter@ToString@NoArgsConstructor@AllArgsConstructorpublic class User implements Serializable &#123; private String name; private int age; private String address;&#125; 执行序列化操作 123456789101112131415161718package com.wick;import com.wick.pojo.User;import java.io.File;import java.io.IOException;import java.io.ObjectOutputStream;import java.nio.file.Files;public class App &#123; public static void main( String[] args ) throws IOException &#123; User user = new User(&quot;wick&quot;, 18, &quot;beijing&quot;); try (ObjectOutputStream os = new ObjectOutputStream(Files.newOutputStream(new File(&quot;user.out&quot;).toPath())))&#123; os.writeObject(user); &#125;; &#125;&#125; 在上面的例子中，我们使用 ObjectOutputStream.writeObject(Object obj ) 方法来完成对象的序列化，并保存到本地文件中，我们可以使用二进制文件编辑器打开看下文件内容 同样的，我们也可以使用 ObjectInputStream.readObject() 方法来将一个对象反序列化出来。 12345678 @Test public void test() throws IOException, ClassNotFoundException &#123; ObjectInputStream ins = new ObjectInputStream(Files.newInputStream(new File(&quot;user.out&quot;).toPath())); User user = (User) ins.readObject(); System.out.println(user); &#125;// out: User(name=wick, age=18, address=beijing) 除了使用默认的序列化机制外，对于一些特殊的类， 我们需要定制序列化和反序列化方法的时候，可以通过重写以下方法实现。 123private void writeObject(java.io.ObjectOutputStream out) throws IOException;private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException;private void readObjectNoData() throws ObjectStreamException; 上面的三个方法，并不是 Serializable 接口中的方法，而是特殊名称的方法，只要实现了 Serializable 接口，就可以通过重写这几个方法来实现定制的序列化和反序列化需求，jdk 中的很多类都有此操作，有兴趣的可以自行查看各自的实现，此处不做展开。 4.1.2 自定义序列化&#x2F;反序列化 对于上面的 User 类，我们可以通过重写 writeObject(java.io.ObjectOutputStream out) 方法来实现自定义的序列化，代码如下所示 123456789101112131415161718192021package com.wick.pojo;import lombok.*;import java.io.IOException;import java.io.Serializable;@Getter@Setter@ToString@NoArgsConstructor@AllArgsConstructorpublic class User implements Serializable &#123; private String name; private int age; private String address; private void writeObject(java.io.ObjectOutputStream s) throws IOException &#123; s.defaultWriteObject(); // 追加 toString() 的内容 s.writeBytes(&quot;name: &quot; + name + &quot;, age: &quot; + age + &quot;, address: &quot; + address); &#125;&#125; 序列化对象 1234567@Testpublic void testSerializer() throws IOException &#123; User user = new User(&quot;wick&quot;, 18, &quot;beijing&quot;); try (ObjectOutputStream os = new ObjectOutputStream(Files.newOutputStream(new File(&quot;user1.out&quot;).toPath())))&#123; os.writeObject(user); &#125;;&#125; 使用工具查看生成的二进制文件内容，可以明显看到后面追加了刚才 toString() 方法的内容，这样就实现了对象的自定义序列化。 同样的，我们也可以通过重写 readObject(java.io.ObjectInputStream s) 方法来实现自定义的反序列化操作 1234567891011private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); // 读取 toString() 的内容 byte[] bytes = new byte[1024]; int len = s.read(bytes); String[] split = new String(bytes, 0, len).split(&quot;,&quot;); // 此处，将 name 和 address 属性交换读取，不然看不出来区别 this.address = split[0].split(&quot;:&quot;)[1].trim(); this.age = Integer.parseInt(split[1].split(&quot;:&quot;)[1].trim()); this.name = split[2].split(&quot;:&quot;)[1].trim(); &#125; 反序列化对象 1234567@Testpublic void test() throws IOException, ClassNotFoundException &#123; ObjectInputStream ins = new ObjectInputStream(Files.newInputStream(new File(&quot;user1.out&quot;).toPath())); User user = (User) ins.readObject(); System.out.println(user.toString());&#125;// out: User(name=beijing, age=18, address=wick) 4.2 实现Externalizable接口除了实现 Serializable 接口完成序列化&#x2F;反序列化外，还可以通过实现 Externalizable 接口达到序列化&#x2F;反序列化的目的， 但是如果实现了 Externalizable 接口， 那就必须实现 writeExternal(ObjectOutput out) 和 readExternal(ObjectInput in) 方法。 以下我们还是以简单的 Person 类来举例。 12345678910111213141516171819202122232425262728293031323334353637383940package com.wick.pojo;import lombok.*;import java.io.Externalizable;import java.io.IOException;import java.io.ObjectInput;import java.io.ObjectOutput;/** * @author: wick * @date: 2023/5/3 12:09 * @description: */@Setter@Getter@NoArgsConstructor // 必须要有无参构造，如果没有重写构造方法，则默认会有无参构造@ToString@AllArgsConstructorpublic class Person implements Externalizable &#123; private String name; private int age; private String address; @Override public void writeExternal(ObjectOutput out) throws IOException &#123; out.writeObject(name); out.writeInt(age); out.writeObject(address); &#125; @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; name = (String) in.readObject(); age = in.readInt(); address = (String) in.readObject(); &#125;&#125; 序列化对象 1234567@Testpublic void test2() throws IOException &#123; Person person = new Person(&quot;wick&quot;, 18, &quot;nanjing&quot;); try (ObjectOutputStream os = new ObjectOutputStream(Files.newOutputStream(new File(&quot;person.out&quot;).toPath())))&#123; os.writeObject(person); &#125;;&#125; 使用工具查看序列化后的内容 反序列化对象 1234567@Testpublic void test3() throws IOException, ClassNotFoundException &#123; ObjectInputStream ins = new ObjectInputStream(Files.newInputStream(new File(&quot;person.out&quot;).toPath())); Person user = (Person) ins.readObject(); System.out.println(user.toString());&#125;// out: Person(name=wick, age=18, address=nanjing) 4.3 两种序列化方式的比较 实现方式 Serializable 接口：是 Java 语言提供的标记接口，即不需要实现任何方法，只需要在类名加上 implements Serializable 即可。当一个对象被序列化时，Java 的序列化机制会把对象的状态保存到一个字节序列中。而当一个对象被反序列化时，Java 的序列化机制会根据保存的字节序列来创建并初始化一个对象。 Externalizable 接口：需要实现 readExternal 和 writeExternal 两个方法，用来表示如何序列化和反序列化一个对象。可以通过这两个方法来控制对象状态的写入和读取。 readExternal 和 writeExternal 方法不是由 Java 序列化机制调用的，而是需要手动调用，因此可以进行一些额外的初始化或特殊操作。 序列化效率 Serializable 接口：在序列化和反序列化一个对象时，序列化机制会自动地对该对象的所有非静态成员进行序列化和反序列化操作。因为使用的是自动序列化机制，这可能会创建一些不必要的对象和字节数组，从而降低序列化的效率，尤其当某个类的父类也实现了可序列化接口时，更耗费资源。 Externalizable 接口：由于对对象的序列化和反序列化过程都是手动控制的，Externalizable 实现的序列化效率比 Serializable 高，特别是在序列化大型对象图时。但是，需要手动调用接口的方法，可能需要更多的代码开销和维护成本。 综上所述，Serializable 接口更加简单且容易实现，但是效率相比于 Externalizable 接口会下降；而 Externalizable 接口需要手动编写序列化和反序列化的方法，但是它提供了更好的控制序列化的过程并且具有更高的序列化效率。 5 Java序列化核心类&#x2F;接口5.1 SerializableSerializable 接口源码如下： 12public interface Serializable &#123;&#125; Serializable 是一个空接口，表明了实现自该接口的子类具有序列化行为特征，所有要支持序列化的类都应该实现这个接口。在后面介绍 ObjectOutputStream 的writeObject 方法时，会解释为什么必须这么做。 5.2 ExternalizableExternalizable 接口源码如下： 123456public interface Externalizable extends java.io.Serializable &#123; void writeExternal(ObjectOutput out) throws IOException; void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;&#125; 此接口有两个必须要重写的方法，在上面我们已经介绍过，writeExternal 的参数是 ObjectOutput，表示输出对象的抽象，它继承自 DataOutput，能支持基本类型、String、数组、对象的输出。实际应用中，会使用它的实现类 ObjectOutputStream。 readExternal 的参数是 ObjectInput，表示输入对象的抽象，它继承自 DataInput，能支持基本类型、String、数组、对象的输入。实际应用中，会使用它的实现类 ObjectInputStream。自定义的类必须包含无参构造函数。 5.3 ObjectOutputStreamjava.io.ObjectOutputStream 是实现序列化的关键类，它可以将一个对象转换成二进制流，然后通过 ObjectInputStream 将二进制流还原成对象。为了能更好地理解 ObjectOutputStream，先简要说明其内部的几个关键类： 5.3.1 BlockDataOutputStreamBlockDataOutputStream 是Java标准库中的一个类，它是DataOutputStream 的子类，用于提供对数据进行块写入的功能。BlockDataOutputStream 类主要用于为ObjectOutputStream 类提供支持。在对象序列化过程中，ObjectOutputStream 会使用 BlockDataOutputStream 来处理原始数据的写入。 以下是BlockDataOutputStream的一些主要特点和功能： 块数据写入：BlockDataOutputStream允许以块的形式，将原始数据按照一组字节进行写入。块数据包含了一些元信息，如块长度、类型等，以便在反序列化时进行正确的解析。 压缩：BlockDataOutputStream 可以对数据进行压缩，以减小序列化数据的大小，提高传输效率。 写入类型：除了基本的数据类型，BlockDataOutputStream 还支持写入字符串、数组、特定类型对象等。 缓冲区管理：BlockDataOutputStream使用内部缓冲区（Buffer）来提高写操作的性能。缓冲区会在需要时被填满并进行刷出。 简单来说，BlockDataOutputStream是用于支持对象序列化过程中的底层数据写入。它提供了块数据写入的功能，可以进行压缩以减小数据大小，同时也实现了缓冲区管理，以提高写入操作的性能。作为 ObjectOutputStream 内置的具有缓冲作用的输出功能类，包含阻塞和非阻塞两种工作模式。两种模式的工作流程相同，都是先把待写的数据写到缓冲区，直到缓冲区满后再执行真正的写入操作，只是在阻塞模式下，每次将缓冲区数据写入之前会写入一个阻塞标记头部（Block Data Header）。 5.3.2 HandleTable管理对象引用的处理，在 Java 的序列化机制中，如果一个对象被多次引用，那么在序列化过程中会将对象序列化为多个拷贝，这样会导致序列化结果变得冗长。为了解决这个问题，Java 序列化机制使用了对象引用句柄。HandleTable 类的作用是维护了一张对象引用句柄表，用来管理对象的序列化和反序列化过程中的引用处理。它通过使用句柄来代替重复的对象，从而实现对象的共享和压缩。具体来说，HandleTable 类中的 handles 数组存储了对象的引用句柄，索引值作为句柄值。当序列化一个对象时，ObjectOutputStream 会将对象写入输出流，并将其句柄（索引值）写入句柄表中。当序列化过程中遇到同一个对象的引用时，它会使用相同的句柄值来表示该对象，这样就实现了对象的共享。在反序列化过程中，ObjectInputStream会根据句柄值从句柄表中获取对应的对象引用。通过使用句柄表，HandleTable 类可以有效地减少序列化结果的大小，并提高序列化和反序列化的效率。它是Java序列化机制中的一个关键组件，帮助实现了序列化对象的共享和压缩。我们可以通过下面一张图来理解这个过程。 在上面这张简单的表示组合关系的类图中，我们可以看到 A 类是由 B 和 C 两个类来组合得到的，而 B，C 类内部都有 T 类，如果没有 HandleTable，那 A类的序列化过程就会变成： 构造对象 B 和 C 在 B 中构造对象 T，在 C 中构造对象 T 从上面这个过程我们发现，T 这个对象会分别在 B 和 C 中被构造一次，如果是更为复杂的对象，那么对于 T 来说，可能会出现非常多的拷贝对象，但是当引入 HandleTable 之后，事情就变得简单了，比先构造对象 B，然后发现用到了 T，则构造一次，并使用一个 Object[] 来缓存这个 T 对象，当构造 C 的时候发现它也用到了对象 T，则直接会从 Object[] 中取到这个对象的引用，避免了二次创建对象，下面是HandleTable类的简化示例： 12345678910111213class HandlesTable &#123; private Object[] handles; // 引用句柄表 public void setObject(int handle, Object obj) &#123; // 设置句柄对应的对象引用 handles[handle] = obj; &#125; public Object getObject(int handle) &#123; // 获取句柄对应的对象引用 return handles[handle]; &#125;&#125; 通过使用数组作为存储结构，HandleTable 能够快速通过句柄值来获取对应的对象引用。通过索引操作，可以直接访问数组的元素，无需进行遍历或搜索操作，因此具有较快的存取速度。当需要序列化和反序列化对象时，HandleTable 会根据需要动态扩展数组的大小，以适应不同数量的对象引用。 5.3.3 ReplaceTableReplaceTable类的主要作用是在序列化过程中，当遇到可以被替换的对象时，将对象替换为其他对象。这样可以更好地控制序列化的结果，实现自定义的序列化逻辑。具体来说，ReplaceTable类维护了一个替换表（Replacement table），它是一个Map数据结构，用于存储对象的替代对应关系。在序列化过程中，当要序列化一个对象时，ObjectOutputStream会检查该对象是否实现了writeReplace()方法。若实现了此方法，ObjectOutputStream会调用该方法获取替代对象，并将替代对象进行序列化。如果替代对象不为null，则将替代对象添加到替换表中。在后续的序列化过程中，如果遇到与替换表中的对象相等的对象时，ObjectOutputStream会将该对象替换为替代对象进行序列化。这样可以在序列化过程中实现对象替换，更好地控制序列化结果。通过使用ReplaceTable类，可以在序列化过程中灵活地替换对象，实现自定义的序列化行为，例如实现对象的版本控制、对象的压缩、对象的安全性检查等。 5.3.4 ObjectStreamClassObjectStreamClass 的主要作用是提供关于类的序列化和反序列化的元数据信息。它存储了与类相关的信息，并在序列化和反序列化时使用这些信息来进行匹配和操作。通过 ObjectStreamClass ，我们可以了解类的版本号、类的字段信息以及类的序列化支持情况等。这使得在进行序列化和反序列化过程时，能够正确地处理对象的属性和版本兼容性。以下是其核心字段及作用： 字段 字段意义 Class&lt;?&gt; cl 序列化类的 Class 类型 String name 序列化类的完整类名 volatile Long suid 序列化 ID，使用 volatile 关键字还可以禁止编译器进行某些优化，例如重排序。这是因为在对象序列化和反序列化的过程中，与版本号相关的操作必须按照特定的顺序进行，否则可能导致不正确的结果。 boolean isProxy 是否是代理类 boolean isEnum 是否是枚举类 boolean serializable 是否实现了 Serializable 接口 boolean externalizable 是否实现了 Externalizable 接口 boolean hasWriteObjectData 是否使用自定义的 writeObject 方法写数据 boolean hasBlockExternalData 类是否包含阻塞式外部数据，阻塞式外部数据指的是在进行对象的序列化时，如果存在某些在序列化过程中需要阻塞的外部数据（比如通过网络传输），那么阻塞式外部数据就会设置为true。 当hasBlockExternalData字段为true时，序列化和反序列化过程中的某些步骤可能会被阻塞，直到外部数据就绪或可用。这样可以确保在序列化和反序列化过程中正确地处理外部依赖。通过这个字段，ObjectStreamClass类在序列化和反序列化时可以根据需要采取相应的行动，以确保阻塞式外部数据正常处理。 ClassNotFoundException resolveEx 尝试解析类时发生的异常 ExceptionInfo deserializeEx 非枚举类反序列化异常，ExceptionInfo 也是 ObjectStreamClass 的一个内部类，表示操作类时产生的异常 ExceptionInfo serializeEx 非枚举类序列化异常 ExceptionInfo defaultSerializeEx 尝试默认序列化时引发的异常 ObjectStreamField[] fields 可序列化字段 int primDataSize 基本类型的成员字段个数，不包含被 static 和 transient 修饰的字段 int numObjFields 非基本类型的成员字段个数 FieldReflector fieldRefl 缓存与类相关联的字段反射信息。它提供了一个快速访问字段的能力，避免了每次进行字段反射访问时的性能开销 volatile ClassDataSlot[] dataLayout 类的层次结构：当前类，父类，及其所有子类的类描述 Constructor&lt;?&gt; cons 适合序列化的构造函数，如果没有，则为 null ProtectionDomain[] domains 与类相关联的保护域（ProtectionDomain）的数组。这些保护域定义了在序列化和反序列化过程中对类的访问权限。ProtectionDomain是Java安全性机制中的一个概念，它代表了一组相关代码的安全域。每个ProtectionDomain都由一个代码源（code source）和一组权限（permissions）组成。当一个对象被序列化时，其类信息会被存储在序列化数据中。在反序列化过程中，为了确保安全性，Java虚拟机（JVM）必须验证反序列化的类是否具有足够的权限进行访问。这个验证过程使用了类的保护域信息。通过domains属性，ObjectStreamClass可以存储和获取与类相关联的保护域信息。这些保护域将在反序列化过程中被用于验证类的访问权限。 Method writeObjectMethod 序列化方法，通过反射获取 Method readObjectMethod 反序列化方法，通过反射获取 Method writeReplaceMethod 当一个对象被序列化时，如果该对象类中定义了writeReplace()方法，那么在序列化过程中将调用这个方法来确定要序列化的对象。writeReplace()方法负责返回实际要序列化的对象。这样可以灵活地控制对象的序列化过程。 Method readObjectNoDataMethod 如果该对象类中定义了readObjectNoData()方法，那么在反序列化过程中将调用这个方法进行对象的初始化。readObjectNoData()方法用于在反序列化之后对反序列化得到的对象进行进一步处理，以确保对象的完整性和一致性 Method readResolveMethod 当一个对象被反序列化时，如果该对象类中定义了readResolve()方法，那么在反序列化过程中将调用这个方法来确定实际要返回的对象。readResolve()方法负责返回一个替代的对象，以确保在反序列化后得到的对象与原始对象保持一致。 ObjectStreamClass localDesc 当前类描述 ObjectStreamClass superDesc 父类描述 boolean initialized 对象是否已经初始化完成 5.4 ObjectInputStreamjava.io.ObjectInputStream 是实现Java反序列化的关键类，和 ObjectOutputStream 是对应的，内部包含了 BlockDataInputStream、HandleTable、ReplaceTable、ObjectStreamClass 等，这里不展开描述。 6. Java 序列化原理以上，我们了解到了 java 实现序列化的方式，以及序列化过程中会用到的核心类&#x2F;接口，接下来我们需要知道Java序列化的流程、原理，以及各种类型数据进行Java序列化后的格式和占用空间大小等细节，这也是序列化技术的核心所在。不同序列化方案的技术细节不尽相同，对各种数据类型处理后的格式和大小也不尽相同。 6.1 基本类型数据序列化流程在学习基本类型的序列化流程之前，我们先回顾两个知识点 Java 中基本数据类型有几种，及其长度 数据类型 字节长度 int 4字节（-2,147,483,648 到 2,147,483,647） long 8字节（-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807） double 8字节（IEEE 754双精度浮点数） char 2字节（无符号Unicode字符，以UTF-16编码表示，可存储一个unicode字符） byte 1字节（-128 到 127） boolean 1 位，只能是 true 或者 false short 2字节（-32,768 到 32,767） float 4字节（IEEE 754单精度浮点数） 字节的高低位 在计算机中，一个字节由8个位（bit）组成。在一个字节中的每个位都有特定的位置。位可以被编号，从最右边的位（称为最低有效位）开始，往左依次递增编号，最左边的位称为最高有效位，也称为高位。其实这个很好理解，在电视上我们也见过支票，支票的金额就是从左往右写的 比如上面这张图，在右边的金额栏，从左往右依次是高单位到低单位，所以最左边的就是高位，最右边的就是低位。 字节的高位和低位术语通常用于表示多字节数据类型（如整数）的个别字节在内存中的存储顺序。在多字节的数据类型中，数据在内存中以连续的字节序列存储，而字节序列的顺序可以是”大端”或”小端”。 大端字节序：最高有效位存储在起始地址，最低有效位存储在最后地址。 小端字节序：最低有效位存储在起始地址，最高有效位存储在最后地址。 举个例子，假设一个整数值0x12345678在内存中按照大端字节序存储。将这个整数值转换为字节序列时，高位字节0x12存储在起始地址，低位字节0x78存储在最后地址。 地址: 0 1 2 3 ​ | 0x12 | 0x34 | 0x56 | 0x78 | 相反，如果按照小端字节序存储，高位字节0x78存储在起始地址，低位字节0x12存储在最后地址。 地址: 0 1 2 3 ​ | 0x78 | 0x56 | 0x34 | 0x12 | 在Java中，默认使用的是采用大端字节序（Big Endian）的内存存储模式。这意味着在多字节数据类型（如int、long、float、double等）存储在内存中时，最高有效字节存储在起始地址，按顺序向后存储。 回顾完上面两个问题，我们继续看 Java 是如何序列化基本类型数据的，Java序列化对基本类型数据的处理，严格按照其内存占用大小来进行。比如int类型占用4字节，Java 序列化按照高位到低位依次放到字节数组，再写入到序列化输出对象，真正的写入是通过调用 BlockDataOutputStream 的 writeInt 方法实现的。BlockDataOutputStream 内部维护了一个1024字节大小的缓冲区，如果缓冲区还可以容纳待写入的 int 类型数据，则把当前数据放入缓冲区；如果缓冲区不能容纳待写入的int类型数据，则调用 DataOutputStream 的 writeInt 方法，如以下代码所示： 接下来我们看下 DataOutputStream 的 writeInt() 方法是如何写 int 类型数据的 我们可以逐步看下这几段代码的含义： out.write(): 很明显这是一个写入操作，可以将内容写入文件或者套接字。 v &gt;&gt;&gt; 24: 这是一个无符号右移操作符，将v向右移动24位（int 长度 4 字节，即 32 位，从第一个字节(8位)开始向右移动24 位即可达到最低位 32 ）。右移操作是将二进制表示中的各位数值向右移动指定的位数，右边的空位用零填充。无符号右移运算符保证移位后左边空出的位总是用零填充。在这个表达式中，我们将整数v的最高8位移动到最低8位，并将其余位数清零，这样就可以提取一个 int 类型变量的最高有效字节的值，而不考虑符号位。 &amp; 0xFF: 这是一个按位与操作符，将上一步的结果与0xFF（十进制为255）进行按位与操作。0xFF的二进制表示为 00000000 00000000 00000000 11111111。这个操作可以确保结果只保留v最高的8位，将其他位数清零。 从上面的代码我们可以看出，确实是按照从高到低的顺序来写入的。我们继续看 out.write() 做了什么(在当前流程中，out 是 BlockDataOutputStream 实例) 如果缓冲区能容纳当前待写入字节，则把当前字节写入缓冲区；如果缓冲区已满，则会先执行 drain 方法把缓冲区的数据输出，再把当前待写入字节放到缓冲区。通过上述流程，一个 int 类型的数据就写完了，其他类型数据流程类似，此处不做展开。 6.2 对象类型数据序列化流程学习完基本类型的序列化流程，我们来看下对象类型的数据是怎么被序列化的。Java序列化对非基本类型的数据处理比基本类型的数据处理更复杂，这里说的非基本类型包括Object、Enum、Array等。Java序列化对非基本类型数据的序列化操作是通过 ObjectOutputStream 的 writeObject 方法实现的，接下来将介绍其内部工作原理。 我们先看下 writeObjet 方法定义 首先检查是否启用了对象写入的重写功能。如果启用了，将调用writeObjectOverride方法，并立即返回。这个条件语句允许自定义的子类重写写入对象的逻辑。obj表示自定义的序列化对象或者Array、Enum类型对象。writeObject0 方法的第2个参数表示一个对象被多个对象共同引用时，在序列化的时候是否要共享写入。如果共享写入，被引用的对象实例只会被序列化一次，其他引用只会写入引用对象句柄。如果不共享写入，被引用的对象实例则会被序列化多次，序列化后的数据大小会增加。在 writeObject 方法里调用 writeObject0，第2个参数默认是false，表示共享写入。 我们继续看下 writeObject0 里面是如何处理非基本类型数据的。 代码比较简单，就是判断 obj 的类型，然后分别调用对应的处理方法，其实如果大家有翻过 String 或者 Enum 的源码，就会发现，这两个类也是实现了 Serializable 接口的，表示这些类都能被正常的序列化。对于Array对象，如果Array的元素是基本类型，则调用基本类型的序列化方式；如果Array的元素是Object类型，则递归调用writeObject0方法来执行序列化，又会执行到上述if分支判断。 如果是自定义的序列化类，则必须实现自Serializable。总之，要能够被 ObjectOutputStream 的 writeObject 方法序列化，对象必须实现自Serializable，否则会抛NotSerializableException异常。 如果是自定义的序列化类，则会执行 writeOrdinaryObject 方法。 我们看下 writeOrdinaryObject 这个方法是如何处理我们自定义的序列化类的。 如果自定义的类是 Externalizable 类型并且不是代理类，则调用writeExternalData方法；否则调用writeSerialData方法。Exernalizable继承自Serializable，并增加了writeExternal和readExternal两个接口。我们继续跟进 writeSerialData方法。 首先获取 obj 对象的布局信息，getClassDataLayout() 表示获取当前类及继承链路上所有直接或间接实现了Serializable的祖先类对应的序列化元数据信息，返回值为ClassDataSlot类型数组，数组元素的顺序是从最根部的祖先类到当前类。ClassDataSlot包含了一个ObjectStreamClass类型的desc字段和boolean类型的hasData字段。ObjectStreamClass类前面已经提过，hasData字段表示desc对应的Java对象是否有数据被序列化。对于ClassDataSlot数组的每一个元素，如果该元素对应的类包含writeObject方法，则调用writeObjet方法。通过查看ObjectStreamClass里的invokeWriteObject方法内部实现，可以看出wirteObject方法以反射方式被调用，代码如下所示。 回到writeSerialData方法内部实现，如果当前待序列化的类没有writeObject方法，则调用defaultWriteFields方法实现序列化，其内部实现如以下代码所示。 流程也比较简单，就是分开处理基本类型和对象类型的数据，其实没有 writeObject() 方法的类，但是还需要序列化的，我们很明显就知道是实现了 Serializable 接口的类，这也就是为什么你实现了这个序列化接口，但是无需实现序列化方法的原因。 回到writeOrdinaryObject方法实现，如果自定义类实现了Externalizable且不是动态代理类，则会调用writeExternalData方法实现序列化，核心代码如下所示。 代码最终调用自定义类对象的writeExternal方法实现写入，看起来比Serializable类更简洁，原因是Externalizable接口中包含了readExternal和writeExternal方法，实现了Externalizable的子类必须覆盖readExternal和writeExternal方法。 7. Java 序列化高级特性7.1 transient 关键字Java序列化可以通过transient关键字来控制字段不被序列化。通过跟进ObjectStreamClass的getDefaultSerialFields方法内部实现，可以看到序列化字段不能为static 且不能为 transient，如以下代码所示： 7.2 static 关键字static字段属于类全局共有，不会被序列化。在反序列化得到的结果里，静态变量的值依赖类对该静态字段的初始化操作以及是否在同一个JVM进程内。比如说静态变量初始值为0，在序列化之前静态变量的值被设置为10，在同一个JVM进程内执行反序列化操作，得到的静态变量的值为10。如果在另外一个JVM进程内执行反序列化操作，得到的静态变量的值为0。这是因为类在JVM进程内只会被加载一次，相同的类在不同的JVM内都会初始化一遍。 7.3 serialVersionUIDserialVersionUID用来实现类版本兼容，在实际开发中能满足类字段变化的需求。如果我们有一个 Person 类，实现了 Serializable 接口，但是没有定义serialVersionUID字段，对Person类增加一个double类型的字段height，再读取增加字段之前的序列化数据，反序列化会报InvalidCastException 异常。如果Person类定义了serialVersionUID字段，对Person类增加一个double类型的字段height，再读取增加字段之前的序列化数据，反序列化可以成功。 serialVersionUID字段必须是 static+final 类型，否则serialVersionUID字段不会被序列化，通过 ObjectStreamClass 的 getDeclaredSUID 方法实现可以得到验证: 如果不定义serialVersionUID字段，Java序列化会根据类字段和其他上下文计算一个默认值。所以，当类字段发生变化时，serialVersionUID值也会跟着变化，就会出现上述因类字段变化导致反序列化失败的问题。在Java编码规范中，应该强制自定义的序列化类包含serialVersionUID字段，各个Java IDE开发工具均能配置针对serialVersionUID的检查告警级别。 7.4 序列化&#x2F;反序列化hook7.4.1 writeReplace 方法writeReplace方法用于序列化写入时拦截并替换成一个自定义的对象。这个方法也是在 ObjectStreamClass 类中被反射获取的 由于writeReplace方法调用是基于反射来执行的，所以作用域限定符不受限制，可以是private、default、protected、public中的任意一种。 如果定义了wirteReplace方法，就没必要再定义writeObject方法了。即使定义了writeObject方法，该方法也不会被调用，内部会先调用writeReplace方法将当前序列化对象替换成自定义目标对象。同理，也没必要定义readObject方法，即使定义了也不会被调用。writeReplace方法的生效原理见ObjectOutputStream的writeObject0方法实现，核心代码如下所示。 7.4.2 readReplace 方法readResolve方法用于反序列化拦截并替换成自定义的对象。但和writeReplace方法不同的是，如果定义了readResolve方法，readObject方法是允许出现的。同样的，readResolve 方法也是在 ObjectStreamClass 类中被反射获取的。 readResolve方法的工作原理为： 首先调用readObject0方法得到反序列化结果。 如果readResolve方法存在，则会调用该方法返回自定义的对象。 将自定义的对象作为ObjectInputStream的readObject的返回值。 readResolve方法用在什么场景呢？常见的一种场景是类实现的枚举类型，枚举对象在反序列化时做恢复性保护。对于类实现的枚举类型，反序列化出来的枚举对象期望是定义的枚举对象，这也体现了枚举的意义。但是从代码执行情况看，反序列化出来的的枚举对象是一个新建出来的枚举对象，虽然值和枚举值定义的一样，但不是同一个对象。因此，需要在反序列化的过程中对枚举对象进行恢复保护，readResolve方法就派上用场了。示例如下： 未使用 readResolve 方法前： 123456789101112131415161718192021222324252627282930313233343536package com.oppo.serializedemo.pojo.po;import lombok.AllArgsConstructor;import lombok.Getter;import lombok.NoArgsConstructor;import lombok.Setter;import java.io.*;/** * @author: wick * @date: 2023/7/29 22:17 * @description: */@Getter@Setter@NoArgsConstructor@AllArgsConstructorpublic class PhoneType implements Serializable &#123; private static final long serialVersionUID = 1L; private int type; public static final PhoneType OPPO = new PhoneType(0); public static final PhoneType VIVO = new PhoneType(1); public static void main(String[] args) throws Exception &#123; ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(new File(&quot;phoneType.out&quot;))); os.writeObject(PhoneType.OPPO); os.close(); ObjectInputStream is = new ObjectInputStream(new FileInputStream(new File(&quot;phoneType.out&quot;))); PhoneType phoneType = (PhoneType) is.readObject(); System.out.println(phoneType == PhoneType.OPPO); // false &#125;&#125; 添加 readResolve 方法: 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.oppo.serializedemo.pojo.po;import lombok.AllArgsConstructor;import lombok.Getter;import lombok.NoArgsConstructor;import lombok.Setter;import java.io.*;/** * @author: wick * @date: 2023/7/29 22:17 * @description: */@Getter@Setter@NoArgsConstructor@AllArgsConstructorpublic class PhoneType implements Serializable &#123; private static final long serialVersionUID = 1L; private int type; public static final PhoneType OPPO = new PhoneType(0); public static final PhoneType VIVO = new PhoneType(1); private Object readResolve() throws ObjectStreamException &#123; if (type == 0) &#123; return OPPO; &#125; else if (type == 1) &#123; return VIVO; &#125; return null; &#125; public static void main(String[] args) throws Exception &#123; ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(new File(&quot;phoneType.out&quot;))); os.writeObject(PhoneType.OPPO); os.close(); ObjectInputStream is = new ObjectInputStream(new FileInputStream(new File(&quot;phoneType.out&quot;))); PhoneType phoneType = (PhoneType) is.readObject(); System.out.println(phoneType == PhoneType.OPPO); // true &#125;&#125; 7.5 数据校验Java序列化机制在反序列化时支持对数据进行校验。这是因为Java序列化后的数据是明文形式，有可能被修改。在反序列化过程中，为了安全起见，可以对读取到的数据进行校验。默认的Java反序列化是不会校验数据的。 使用数据校验特性，需要让自定义的序列化类实现 java.io.ObjectInputValidation 接口，通过调用回调函数 validateObject 来实现数据验证。此处给出示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.oppo.serializedemo.pojo.po;import lombok.*;import java.io.*;import java.util.Objects;/** * @author: wick * @date: 2023/7/30 10:45 * @description: */@Getter@Setter@NoArgsConstructor@AllArgsConstructor@ToStringpublic class User implements Serializable, ObjectInputValidation &#123; private static final long serialVersionUID = 1L; private String name; @Override public void validateObject() throws InvalidObjectException &#123; if (Objects.equals(name, &quot;zhangSan&quot;)) &#123; throw new InvalidObjectException(&quot;用户已经被禁用&quot;); &#125; &#125; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; in.defaultReadObject(); // 执行默认的反序列化操作 validateObject(); // 在反序列化完成后进行对象验证 &#125; public static void main(String[] args) throws Exception &#123; ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(&quot;user&quot;)); User user = new User(&quot;zhangSan&quot;); os.writeObject(user); os.close(); ObjectInputStream is = new ObjectInputStream(new FileInputStream(&quot;user&quot;)); // 在此处就会抛出异常：java.io.InvalidObjectException: 用户已经被禁用 User user1 = (User) is.readObject(); is.close(); System.out.println(user1); &#125;&#125; 8 选择 Serializable 还是 Externalizable在Java序列化应用方面，读者应该会困惑两种机制应选择哪种。从功能角度看，二者都是Java序列化已经支持的。从易用性方面来考虑，Serializable比Externalizable易用性好。首先，Serializable提供了默认的序列化与反序列化行为，用户不需要关注序列化的实现细节即可拿来使用；而Externalizable必须实现readExternal和writeExternal接口且要提供默认构造函数。其次，在自定义序列化行为方面，Serializable也可以通过readObject和writeObject来支持。 对于初学者或者对自己代码水平没啥自信的同学，可以优先选择Serializable。从很多JDK源码和开源代码中可以看到，序列化接口都实现自Serializable。在继承链路上，如果要终止一个子类的Serializable或者Externaizable特性，则在readObject&#x2F;writeObject方法或readExternal&#x2F;writeExternal方法接口里抛出 UnsupportedOperationException 异常，表示不支持序列化和反序列化功能。 9. Java序列化安全Java序列化后的数据是明文形式，而且数据的组成格式有明确的规律。当这些数据脱离Java安全体系存在磁盘中时，可以通过二进制数编辑工具查看，甚至修改。如果这些数据注入了病毒，应用程序的表现行为将无法预计。为了保障数据的安全性，引入SealedObject和SignedObject对序列化数据进行加密。 9.1 SealedObject以下演示如何使用 SealedObject 来保证序列化&#x2F;反序列化安全 12345678910111213141516171819202122232425262728293031323334353637383940package com.oppo.serializedemo.pojo.po;import lombok.*;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.SealedObject;import javax.crypto.SecretKey;import java.io.FileOutputStream;import java.io.ObjectOutputStream;import java.io.Serializable;/** * @author: wick * @date: 2023/7/30 10:45 * @description: */@Getter@Setter@NoArgsConstructor@AllArgsConstructor@ToStringpublic class User implements Serializable &#123; private static final long serialVersionUID = 1L; private String name; private Integer age; public static void main(String[] args) throws Exception &#123; ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(&quot;user&quot;)); SecretKey key = KeyGenerator.getInstance(&quot;DESede&quot;).generateKey(); Cipher cipher = Cipher.getInstance(&quot;DESede&quot;); cipher.init(Cipher.ENCRYPT_MODE, key); User user = new User(&quot;zhangSan&quot;, 18); SealedObject sealedObject = new SealedObject(user, cipher); os.writeObject(sealedObject); os.close(); &#125;&#125; 使用二进制工具查看 user 文件，发现跟我们之前未加密的数据不一样，连基本字段和值都看不到了 我们直接使用 ObjectInputStream 反序列化一下试试 123456789101112131415161718192021222324252627282930313233343536373839404142package com.oppo.serializedemo.pojo.po;import lombok.*;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.SealedObject;import javax.crypto.SecretKey;import java.io.*;/** * @author: wick * @date: 2023/7/30 10:45 * @description: */@Getter@Setter@NoArgsConstructor@AllArgsConstructor@ToStringpublic class User implements Serializable &#123; private static final long serialVersionUID = 1L; private String name; private Integer age; public static void main(String[] args) throws Exception &#123; ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(&quot;user&quot;)); SecretKey key = KeyGenerator.getInstance(&quot;DESede&quot;).generateKey(); Cipher cipher = Cipher.getInstance(&quot;DESede&quot;); cipher.init(Cipher.ENCRYPT_MODE, key); User user = new User(&quot;zhangSan&quot;, 18); SealedObject sealedObject = new SealedObject(user, cipher); os.writeObject(sealedObject); os.close(); ObjectInputStream is = new ObjectInputStream(new FileInputStream(&quot;user&quot;)); SealedObject sealedObject1 = (SealedObject) is.readObject(); is.close(); User u1 = (User) sealedObject1.getObject(key); System.out.println(u1); // User(name=zhangSan, age=18) &#125;&#125; 至此，我们就通过一个加密&#x2F;解密的手段来保护了对象在序列化&#x2F;反序列化过程中的安全。 9.2 SignedObjectSignedObject 也是通过加解密的方式来保护序列化安全的，示例如下： 1234567891011121314151617181920212223242526272829303132333435363738package com.oppo.serializedemo.pojo.po;import lombok.*;import java.io.*;import java.security.KeyPair;import java.security.KeyPairGenerator;import java.security.Signature;import java.security.SignedObject;/** * @author: wick * @date: 2023/7/30 11:26 * @description: */@Getter@Setter@NoArgsConstructor@AllArgsConstructor@ToStringpublic class Account implements Serializable &#123; private String name; private Double money; public static void main(String[] args) throws Exception &#123; ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(&quot;account&quot;)); KeyPair keyPair = KeyPairGenerator.getInstance(&quot;RSA&quot;).generateKeyPair(); Account account = new Account(&quot;zhangSan&quot;, 1000.0); SignedObject signedObject = new SignedObject(account, keyPair.getPrivate(), Signature.getInstance(&quot;SHA256withRSA&quot;)); os.writeObject(signedObject); os.close(); ObjectInputStream is = new ObjectInputStream(new FileInputStream(&quot;account&quot;)); SignedObject signedObject1 = (SignedObject) is.readObject(); Account account1 = (Account) signedObject1.getObject(); System.out.println(account1); &#125;&#125; 10. 总结Java序列化方案成熟度高，但性能和压缩效果均一般，只适合JVM系列语言共享数据，不具备完全的跨语言能力。另外，它会带来一些数据安全性和完整性问题。在我们真正的 web 开发过程中，基本不会去使用以上的序列化方式，而是往往会选择具有跨语言能力、性能高效、压缩效果显著的方案，例如Thrift、Protocol Buffer、Json、Xml 等。但是了解 Java 的序列化&#x2F;反序列化过程，对于程序员能力的提升，还是有较大的意义。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://linvaux.github.io/tags/Java/"}]},{"title":"Jmeter源码系列(3) - Jmeter 类详解-start方法，Jmeter 真正的启动过程","slug":"Jmeter源码系列-3-Jmeter-类详解-start方法，Jmeter-真正的启动过程","date":"2024-07-26T14:07:00.000Z","updated":"2024-07-26T14:13:49.599Z","comments":true,"path":"2024/07/26/Jmeter源码系列-3-Jmeter-类详解-start方法，Jmeter-真正的启动过程/","permalink":"https://linvaux.github.io/2024/07/26/Jmeter%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-3-Jmeter-%E7%B1%BB%E8%AF%A6%E8%A7%A3-start%E6%96%B9%E6%B3%95%EF%BC%8CJmeter-%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/","excerpt":"","text":"在开始讲 start 方法前，大家先考虑一个问题，Jmeter 启动时带不带参数有什么影响？我们可以带着这个问题往下看。 Jmeter启动参数是如何传递的？在前面两篇文章中，已经跟大家非常详细的介绍了 Jmeter 启动时会做什么，回顾一下就是： 调用 NewDriver.main(String[] args) 方法，此方法会反射调用 Jmeter.start(String[] args) 方法。 在执行 Jmeter.start(String[] args) 方法前，Jmeter 类现需要实例化，这个类中包含了非常多的静态常量，绝大多数都是跟启动参数相关，这些参数会在类实例化时也被初始化掉。 那么这些参数是从哪来的呢？其实入口就是 NewDriver.main(String[] args) ，这个方法的参数列表可以从 Jmeter 的启动脚本获取，也可以通过执行 1java -jar ApacheJMeter.jar xxx 来启动 后面的 xxx 表示的就是启动参数，跟执行以下命令效果一样 1jmeter xxx 我们可以通过查看 Jmeter &#x2F;bin 目录下的 jmeter 脚本来验证这个过程，以下内容是 JMeter 在 mac 下的启动脚本，其中只保留了最后几行内容，其他系统下的脚本内容也是类似，就不在此处展开解释。这段脚本其实很简单，就是判断 JMETER_COMPLETE_ARGS 这个变量是不是为空，用来控制 ARGS 参数值，最后一行就是很普通的 java 应用启动命令，后面的 “$@” 是一个特殊变量，用于表示所有向脚本传递的位置参数（命令行参数）。具体来说，$@ 会将所有的位置参数作为一个单独的字符串列表返回。每个位置参数会被当作一个独立的字符串，在使用时可以通过遍历 $@ 获取每个参数。需要注意的是，”$@” 使用双引号括起来时，会将每个位置参数作为独立的字符串处理，保留参数中的空格和特殊字符。这样可以确保传递参数时的正确性，在处理包含空格或特殊字符的参数时非常有用。 顺便提一句，上面判断了 JMETER_COMPLETE_ARGS 是为了给 Java9 单独设置一些启动参数，因为在 Java 9 之前的版本中，可以使用标准的 JAVA_OPTS 环境变量来设置 Java 虚拟机的选项。然而，从 Java 9 开始，Oracle 官方建议使用 JAVA_TOOL_OPTIONS 环境变量来设置 Java 应用程序的选项，以便与新的模块化系统和命令行标志兼容。为了确保 JMeter 在不同版本的 Java 中都能正常运行，并且可以方便地配置 Java 9 相关的选项，此处单独处理了 Java 9 的选项设置。通过使用 JAVA9_OPTS 环境变量存储 Java 9 相关的选项，并将其与其他选项拼接到 ARGS 字符串中，以便将这些选项传递给 JMeter 启动脚本。这种单独处理 Java 9 的选项，能够更好地适应不同版本的 Java，并确保在升级或切换 Java 版本时不会影响到 JMeter 的启动脚本和选项设置。这样做的目的是为了提高 JMeter 的兼容性和可移植性。 ok，那现在我们知道了，NewDeriver.main(String[] args) 会接受命令行参数，然后 main 方法再反射调用 Jmeter.start(String[] args) 时，也会把参数传递下去，代码如图所示：invoke 方法第二个参数 args 就是 main 方法接收到的参数，这就完成了参数从命令行传递给 Jmeter 的过程，在实例化 Jmeter 时，这些参数又被 CLOptionDescriptor 类处理了一次，从一堆字符串变成了一个对象，方便 Jmeter 更好的处理参数，那接下来我们迎来了本文章的重点：Jmeter.start(String[] args) 方法到底做了什么？ Jmeter 是如何启动的？在解释代码之前，大家有没有发现一个现象： 当我们什么启动参数都不带时，Jmeter 会直接以 GUI 模式启动，我们可以写脚本调试，甚至直接开始测试，也可以不跑测试，写个脚本就把它关掉。但是当我们使用 cli 时，就可以直接传递一个 jmx 脚本给 Jmeter，这时 Jmeter 就会直接开始测试。这两种方式是如何实现的呢？ 如果大家有观察过这个现象，那接下来的内容会非常容易理解，因为这涉及到了 Jmeter 的 2 种启动模式： startGui startNonGui 但是这个时候大家会疑惑，之前不是说 Jmeter 有三种启动模式么，分别是：GUI，NON-GUI, SERVER，为啥到这边又成了 2 种了？ 其实，这前后并没有矛盾，因为 SERVER 和 NON-GUI 模式都是属于 NON-GUI 的方式启动，我们此处只是讨论 Jmeter 在启动时的宏观表现，即有没有图形界面。 接下来，我们就开始从代码出发，看下 Jmeter 真正的启动过程。 1.命令行参数校验在进入 start 方法后，会先对命令行参数的组合进行判断，如果参数组合不支持，则生成一个 error 信息，然后判断 error 是否为 null，如果有错误信息，则停止启动，并在控制台输出错误信息。 2.初始化运行环境参数校验通过之后，Jmeter 会进行运行环境初始化，虽然 NewDriver 已经初始化过一次(主要做类加载)，但是 Jmeter 会做更细致的初始化动作，以下是 Jmeter 初始化内容 初始化 Properties：实现方法为 Jmeter.initializeProperties(CLArgsParser parser) 方法。首先检查用户是否通过 -p 参数设置了 property 文件，如果没有设置，则直接使用 bin&#x2F;jmeter.properties 文件。其次设置 Jmeter 语言环境，设置 JmeterHome，还有就是读取 user.properties，system.properties 以及用户通过命令行参数自己指定的 property 文件，最后设置下日志等级。 添加安全提供程序：根据给定的 Properties 对象，筛选匹配特定模式的键值对，并按照键的顺序逐个调用 addSecurityProvider 方法，作用是：(1)扩展功能：通过添加安全提供程序，可以扩展 Java 程序的加密、签名、哈希等安全功能，使其支持更多的算法和标准。这样，程序就可以使用更多安全服务来满足特定的需求。(2)第三方库或协议支持：有些第三方库或协议可能需要特定的加密、签名或认证机制。通过添加相应安全提供程序，可以为这些库或协议提供所需的支持，确保程序能够与它们进行兼容性的交互。(3)安全策略和规范：在某些情况下，出于安全策略和规范的考虑，需要使用特定的安全提供程序来确保符合特定的安全要求。通过添加这些提供程序，可以实施和遵循特定的安全标准。 设置默认的未捕获异常处理器：当发生未捕获异常时，使用注册的异常处理器进行处理，即在控制台输出异常信息。 设置代理：因为用户可以通过命令行参数设置代理服务器，代码比较简单，就不展开讲解了，知道是做什么就行了。 更新加载的类：又去把一堆类加载进来，核心还是调用 NewDriver.addURL(path); 方法。此处不展开讲解。 设置几个属性：设置开始时间，开始日期，以及开始的时分秒，但是感觉没啥鸟用，连注释都写了：Set some (hopefully!) useful properties，意思就是希望这几个参数你能用得上。 3.Jmeter 真正的启动 首先，判断用户有没有使用 -s 参数，如果用了这个参数，则使用 Server 模式启动。下面还有个 startOptionalServers(); 方法，其实不管是哪种启动方式，都会执行这个方法，它的作用就是根据配置启动可选的 Beanshell 服务器和 Mirror 服务器。Beanshell 服务器提供了自定义逻辑的执行能力，而 Mirror 服务器则用于模拟外部服务器行为。通过这些服务器，用户可以在测试期间执行自定义逻辑和模拟环境，以满足特定的测试需求。 接下来判断是否使用了 -t 和 -g 两个参数，-t 用来指定 jmx 文件，-g 用来生成报告。注意，此时并没有真的把 jmx 文件加载进 Jmeter，更没有生成报告，只是做了参数的赋值操作。 继续判断是否使用了 -n 参数，如果没有使用这个参数，则会启动图形界面。在启动图形界面前，会先调用PluginManager.install(this, true);方法来加载插件，还记得之前讲过Jmeter 实现了JMeterPlugin 接口么？作用就在此处体现了，要去加载 Jmeter 的图标和其他的资源文件。然后就会真正的启动 GUI 了，同时会在控制台打印一段熟悉的内容此时，Jmeter 通过图形界面真正的启动了，当然如果你在启动前指定了 jmx 文件，那么 Jmeter 打开之后，就会默认加载这个文件，否则就是默认新建 TestPlan 的页面。 如果用户使用了 -n 参数，则说明要使用 NON-GUI 启动。启动流程也很简单，先检查下几个文件夹能不能正常写入，比如通过 -o 参数指定的报告文件夹，Jmeter 默认的报告输出文件夹等。然后就是检查是否通过 -R 指定了远程执行的机器，通过 -t 生成 jtl 文件，再检查使用了 -e 参数之后，-t 参数是不是为 null，如果没有指定要生成 jtl 文件，但是要求生成报告的话，则会抛异常，因为 Jmeter 的报告就是通过解析 jtl 文件得到的，具体是怎么生成的，会在后面的章节中跟大家探讨。最后调用 startNonGui()方法来启动无界面模式的 Jmeter。 4.总结至此，让我们通过一张图来了解下 Jmeter 的启动过程 此时，Jmeter 算是真正的启动起来了，因为 GUI 模式启动涉及到大量关于 Java Swing 的内容，不在本文章讨论范围内，我会主要从 NON-GUI 模式来跟大家讲解 Jmeter 的运行原理，因为两种模式本质上都是通过 Jmeter 执行引擎来实现测试的。下一章开始，我们将继续深入了解使用无界面模式启动后，Jmeter 是如何开始测试的…","categories":[],"tags":[{"name":"Jmeter源码系列","slug":"Jmeter源码系列","permalink":"https://linvaux.github.io/tags/Jmeter%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"}]},{"title":"Jmeter源码系列(2) - Jmeter 类详解-命令行参数处理CLOptionDescriptor","slug":"Jmeter源码系列-2-Jmeter-类详解-命令行参数处理CLOptionDescriptor","date":"2024-07-26T14:06:03.000Z","updated":"2024-07-26T14:06:19.576Z","comments":true,"path":"2024/07/26/Jmeter源码系列-2-Jmeter-类详解-命令行参数处理CLOptionDescriptor/","permalink":"https://linvaux.github.io/2024/07/26/Jmeter%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-2-Jmeter-%E7%B1%BB%E8%AF%A6%E8%A7%A3-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86CLOptionDescriptor/","excerpt":"","text":"上一篇我们详细了解了 Jmeter 的启动类 NewDriver，知道了 NewDriver 会通过反射调用 Jmeter.start(String[] args)方法来启动 Jmeter，今天我们来分析下，Jmeter这个类内部到底做了什么。本篇章不会直接开始讲 start 方法，而是会先讲一下 Jmeter 类里面设置的 static 变量，因为这些变量会影响 jmeter 启动时的一些行为。 Jmeter 类的作用Jmeter类位于 org.apache.jmeter 包下，通过类注释可以了解到它的作用 123/** * Main JMeter class; processes options and starts the GUI, non-GUI or server as appropriate. */ Jmeter.class 是 Jmeter 的主要类，是为了让 Jmeter 通过 GUI，NON-GUI 或者server模式启动。通过我们使用 Jmeter 工具也能发现，Jmeter 正常情况下启动会有用户界面，方便我们编写 jmx 脚本或者调试 jmx 脚本。但是也可以通过 jmeter -n 模式来启动命令行模式(此处应该是无界面模式更合适)执行 jmx 脚本，并且在 Jmeter 启动时，console 里面也会打印如下内容： 12345678================================================================================Don&#x27;t use GUI mode for load testing !, only for Test creation and Test debugging.For load testing, use CLI Mode (was NON GUI): jmeter -n -t [jmx file] -l [results file] -e -o [Path to web report folder]&amp; increase Java Heap to meet your test requirements: Modify current env variable HEAP=&quot;-Xms1g -Xmx1g -XX:MaxMetaspaceSize=256m&quot; in the jmeter batch fileCheck : https://jmeter.apache.org/usermanual/best-practices.html================================================================================ 这段内容其实包含 2 个关键内容： 调试 jmx 脚本的时候可以使用有界面模式，如果要进行测试的话，建议我们使用CLI模式，即无界面模式。 告诉用户如何配置 Jmeter 的堆内存，因为 Jmeter 本身是基于 Java 开发，也是运行在 JVM 虚拟机上的，所以如果我们进行性能测试前，可以适当调整堆内存，来防止测试过程中发生 OOM 等异常。 除了有界面和无界面两种启动模式，Jmeter 还有一种server模式，即集群模式。Jmeter 本身是支持分布式压测的，当单机的并发能力存在瓶颈的时候，可以通过配置 slave 节点来实现分布式压测，这个时候，Jmeter 就是以 server 模式启动的。 Jmeter 中的 CLOptionDescriptor打开 org.apache.jmeter.Jmeter.java 源码，我们会发现，这个类内部定义了几十个静态变量，而且这个类还实现了一个 JMeterPlugin 接口。我们先看JMeterPlugin接口，此接口内部只有两个方法 String[][] getIconMappings(); String[][] getResourceBundles(); 第一个 getIconMappings() 方法用于获取插件中的图标映射信息。返回一个二维字符串数组，每个数组元素包含两个字符串：图标名称和图标文件的路径。这些图标文件可以用于在 JMeter 用户界面中显示插件的图标。通过实现 getIconMappings() 方法并返回相应的图标映射，插件可以将自定义的图标与插件相关联，并在 JMeter 中展示出来，以提供更好的用户体验和可视化效果。我们使用 Jmeter 的时候就能发现，每个组件前面都会带个小图标，就是通过这个方法来去加载这些图标的。 第二个 getResourceBundles() 其实更容易理解，如果大家开发过 web 项目，知道 resourceBundles 是啥，没错，就是用来做国际化的。这个方法用于获取插件中的资源绑定信息。返回一个二维字符串数组，每个数组元素包含两个字符串：资源包的基本名称和资源包的位置。资源包是包含本地化文本消息、错误消息、标签等的文件集合，用于国际化和本地化插件的用户界面。通过实现 getResourceBundles() 方法并返回相应的资源绑定信息，插件可以实现多语言支持，并根据用户的语言环境动态加载适当的本地化资源。 接下来，我们看下 Jmeter 中定义了这么多变量有啥用，当然，我不会把每个变量都解释一遍，只会对关键部分做解释说明。在这些变量中，有很多变量是类似于以下这种： 1private static final int REMOTE_OPT_PARAM = &#x27;R&#x27;; 大家要注意，这个变量类型是 int，并不是 char，因为这个变量其实是代表了’R’的 ASCII 编码值（十进制数）也就是：82。这种做法是为了提高代码的可读性和可维护性。通过使用命名的常量，代码的其他部分可以直接使用 REMOTE_OPT_PARAM 来表示这个特定的值，而不是使用硬编码的字符 ‘R’ 或数字 82。这样，如果将来需要更改这个值，只需修改常量的定义即可，而不需要对代码中所有引用到这个值的地方进行修改。 这种定义的变量，会被一个叫 CLOptionDescriptor 的类解析，我们先看下这个类它的作用是什么，其实第一眼看到这个类名的时候，就能大概猜出来，这是用来解析命令行参数的。它其实是 Apache Commons CLI 库中的一个类，作用就是解析命令行参数，提供了定义选项的名称、别名、描述、参数属性和行为的方法。这个类具体的作用如下： 描述选项的名称和别名：CLOptionDescriptor 允许您定义选项的名称、短名称和长名称等标识符。通过这些标识符，您可以在命令行中识别并指定特定的选项。 指定选项的描述信息：CLOptionDescriptor 允许您为选项提供文本描述或帮助信息，以帮助用户理解该选项的作用和用法。 指定选项的参数属性：CLOptionDescriptor 可以定义选项是否需要参数以及参数的类型。它支持定义选项是否需要参数、参数的最少和最多出现次数、参数的默认值等属性。 配置选项的行为：CLOptionDescriptor 提供了一些方法来配置选项的行为。例如，您可以定义选项是否为必需选项、是否允许多次使用、是否支持可变参数数量等。 所以，这个类的作用，就是在 CLI 模式下，解析参数用的。比如当我们使用命令 1jmeter -h 就可以看到以下输出： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 _ ____ _ ____ _ _ _____ _ __ __ _____ _____ _____ ____ / \\ | _ \\ / \\ / ___| | | | ____| | | \\/ | ____|_ _| ____| _ \\ / _ \\ | |_) / _ \\| | | |_| | _| _ | | |\\/| | _| | | | _| | |_) | / ___ \\| __/ ___ \\ |___| _ | |___ | |_| | | | | |___ | | | |___| _ &lt;/_/ \\_\\_| /_/ \\_\\____|_| |_|_____| \\___/|_| |_|_____| |_| |_____|_| \\_\\ 5.4.1Copyright (c) 1999-2021 The Apache Software FoundationTo list all command line options, open a command prompt and type:jmeter.bat(Windows)/jmeter.sh(Linux) -?--------------------------------------------------To run Apache JMeter in GUI mode, open a command prompt and type:jmeter.bat(Windows)/jmeter.sh(Linux) [-p property-file]--------------------------------------------------To run Apache JMeter in NON_GUI mode:Open a command prompt (or Unix shell) and type:jmeter.bat(Windows)/jmeter.sh(Linux) -n -t test-file [-p property-file] [-l results-file] [-j log-file]--------------------------------------------------To run Apache JMeter in NON_GUI mode and generate a report at end :Open a command prompt (or Unix shell) and type:jmeter.bat(Windows)/jmeter.sh(Linux) -n -t test-file [-p property-file] [-l results-file] [-j log-file] -e -o [Path to output folder]--------------------------------------------------To generate a Report from existing CSV file:Open a command prompt (or Unix shell) and type:jmeter.bat(Windows)/jmeter.sh(Linux) -g [csv results file] -o [path to output folder (empty or not existing)]--------------------------------------------------To tell Apache JMeter to use a proxy server:Open a command prompt and type:jmeter.bat(Windows)/jmeter.sh(Linux) -H [your.proxy.server] -P [your proxy server port]---------------------------------------------------To run Apache JMeter in server mode:Open a command prompt and type:jmeter-server.bat(Windows)/jmeter-server(Linux)--------------------------------------------------- 那么这些输出是哪里来的呢？很明显不是 CLOptionDescriptor 打印的，因为这个类的作用就是解析长短参数，还有参数提示，并不会给出命令执行的结果，我们翻一下代码就能看到，其实这个命令的结果是被 Jmeter 处理之后返回的这段代码就在 Jmeter.start(String[] args) 方法中，判断了参数列表是不是包含 ‘h’,然后打印了 org&#x2F;apache&#x2F;jmeter&#x2F;help.txt 这个文件的内容，我们也可以打开这个文件，看下内容是不是一样的我们可以看到，打印内容基本一致，但是少了一个 banner 图，那是因为 banner 图是在上面的 displayAsciiArt()方法中打印的，我们也可以顺便看下这段打印 banner 的代码： 1234567891011private void displayAsciiArt() &#123; try (InputStream inputStream = JMeter.class.getResourceAsStream(&quot;jmeter_as_ascii_art.txt&quot;)) &#123; if(inputStream != null) &#123; String text = IOUtils.toString(inputStream, StandardCharsets.UTF_8); System.out.println(text);//NOSONAR &#125; &#125; catch (Exception e1) &#123; //NOSONAR No logging here System.out.println(JMeterUtils.getJMeterCopyright());//NOSONAR System.out.println(&quot;Version &quot; + JMeterUtils.getJMeterVersion());//NOSONAR &#125; &#125; 代码其实很简单，就是读了一个文件，然后输出到控制台，仅此而已。所以，综上所述，Jmeter 这个类，内部的静态变量其实就是在解析命令行参数，最后这些参数会被存储在 CLOptionDescriptor[] options 对象中，这个 option 对象非常重要，因为在 jmeter 真正启动前，会从 option 中获取好几个参数，来决定使用何种启动方式。 Jmeter 支持的命令行参数 短命令 长命令 说明 -h --help 显示帮助信息。 -v --version 显示 JMeter 版本信息。 -n --nongui 以非 GUI （无界面）模式运行 JMeter。 -t &lt;文件名&gt; --testfile &lt;文件名&gt; 指定要执行的 JMX 测试计划文件。 -l &lt;文件名&gt; --logfile &lt;文件名&gt; 指定测试结果的日志文件名。 -j &lt;文件名&gt; --jmeterlogfile &lt;文件名&gt; 指定 JMeter 的日志文件名。 -r --runremote 以远程方式运行测试计划，用于分布式测试。 -R &lt;远程主机列表&gt; --remotestart &lt;远程主机列表&gt; 通过指定远程主机列表，以分布式方式运行测试计划。 -G &lt;属性文件&gt; --globalproperties &lt;属性文件&gt; 指定全局属性文件。 -D &lt;name&gt;=&lt;value&gt; --systemproperty &lt;name&gt;=&lt;value&gt; 设置额外的系统属性。 -S --systemPropertiesFile &lt;文件名&gt; 指定系统属性文件。 -P &lt;name&gt;=&lt;value&gt; --jmeterproperty &lt;name&gt;=&lt;value&gt; 设置 JMeter 属性值。此处参数是小写 -H &lt;代理主机&gt; --proxyHost &lt;代理主机&gt; 指定代理服务器的主机名。 -P &lt;代理端口&gt; --proxyPort &lt;代理端口&gt; 指定代理服务器的端口号。此处参数是大写 -N &lt;非代理的主机列表&gt; --nonProxyHosts &lt;非代理的主机列表&gt; 指定不需要代理的主机。 -X --remoteexit 告知远程服务器在测试结束后退出。 -H --help-report 显示关于报告生成的帮助信息。 -L --loglevel 指定 JMeter 日志的级别。 -q &lt;属性文件&gt; --addprop &lt;属性文件&gt; 指定要加载的其他 JMeter 属性文件。 -s --server 以服务器模式运行 JMeter 使用 JMeter 远程实例。 -f --forceDeleteResultFile 在运行之前强制删除已存在的测试结果文件。 -i --ignorelineendings 忽略测试计划文件中的行结束标记。 -H --useSystemProxy 使用系统代理设置。 后面一章正式讲解 Jmeter.start(String[] args) 方法。","categories":[],"tags":[{"name":"Jmeter源码系列","slug":"Jmeter源码系列","permalink":"https://linvaux.github.io/tags/Jmeter%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"}]},{"title":"Jmeter源码系列(1)-NewDriver类详解-Jmeter 的启动器","slug":"Jmeter源码系列-1-NewDriver类详解-Jmeter-的启动器","date":"2024-07-26T14:04:18.000Z","updated":"2024-07-26T14:05:12.166Z","comments":true,"path":"2024/07/26/Jmeter源码系列-1-NewDriver类详解-Jmeter-的启动器/","permalink":"https://linvaux.github.io/2024/07/26/Jmeter%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-1-NewDriver%E7%B1%BB%E8%AF%A6%E8%A7%A3-Jmeter-%E7%9A%84%E5%90%AF%E5%8A%A8%E5%99%A8/","excerpt":"","text":"写在前面的话Jmeter 全称（Apache JMeter）是一个开源的、功能强大的性能测试工具，用于对各种应用程序和协议进行功能、负载、压力和性能测试。它被广泛应用于软件开发和计划阶段，以确保应用程序在各种负载情况下的稳定性和可靠性。本系列将从 Jmeter 代码层面陆续剖析其实现原理，包括但不限于 Jmeter 设计思路，Jmeter 核心对象&#x2F;接口&#x2F;方法。如有错误，敬请指正！ NewDriverNewDriver 是 org.apache.jmeter 包下的一个类，如下是 NewDriver 源码中的类说明 123/** * Main class for JMeter - sets up initial classpath and the loader. */ 从这个说明中，我们可以知道，这个类提供了 2 个主要功能： 初始化 classpath 初始化一个 loader, 这个 loader 其实就是一个动态类加载器 以下内容摘抄自 NewDriver 源码，在源码中会使用注释来说明关键代码的作用，最后也会做总结，让我们开始吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public final class NewDriver &#123; /** * 定义一堆常量，会在 static 代码块中使用 */ private static final String CLASSPATH_SEPARATOR = File.pathSeparator; private static final String OS_NAME = System.getProperty(&quot;os.name&quot;); private static final String OS_NAME_LC = OS_NAME.toLowerCase(java.util.Locale.ENGLISH); private static final String JAVA_CLASS_PATH = &quot;java.class.path&quot;; private static final String JMETER_LOGFILE_SYSTEM_PROPERTY = &quot;jmeter.logfile&quot;; private static final String HEADLESS_MODE_PROPERTY = &quot;java.awt.headless&quot;; /** * 动态类加载器，继承自 URLClassLoader，提供了一个静态方法 updateLoader(URL [] urls) 实现了动态加载 jar * 的功能。 */ private static final DynamicClassLoader loader; private static final String JMETER_INSTALLATION_DIRECTORY; private static final List&lt;Exception&gt; EXCEPTIONS_IN_INIT = new ArrayList&lt;&gt;(); static &#123; final List&lt;URL&gt; jars = new ArrayList&lt;&gt;(); /** * 启动时从 jvm 获取 classpath */ final String initiaClasspath = System.getProperty(JAVA_CLASS_PATH); String tmpDir; /** * 按照指定标记符来分割给定的字符串，但是 StringTokenizer 是一个遗留类，出于兼容性原因而保留，建议使用 String 的拆分方法或 java.util.regex 包。 * 顺便说一下，Jmeter 源码中会包含非常多的过时的方法或者写法，有些是因为 Jmeter 本身开发较早，当时的 jdk 版本没有我们常用的新方法， * 有些则是因为当时 jdk 早期版本存在 bug，jmeter 会使用另一种写法来规避这些 bug，当然，现在这些 bug 可能已经修复了，不过 jmeter 的源码中 * 任然会保留这部分注释 */ StringTokenizer tok = new StringTokenizer(initiaClasspath, File.pathSeparator); /** * 对 mac 系统做了单独的判断，我也没有深究为啥要单独处理，不晓得现在还需不需要这么写 */ if (tok.countTokens() == 1|| (tok.countTokens() == 2 &amp;&amp; OS_NAME_LC.startsWith(&quot;mac os x&quot;))) &#123; File jar = new File(tok.nextToken()); try &#123; tmpDir = jar.getCanonicalFile().getParentFile().getParent(); &#125; catch (IOException e) &#123; tmpDir = null; &#125; &#125; else &#123; /** * 从 jvm 获取 jmeter.home 属性，没有的话就默认从环境变量 JMETER_HOME 取值，当然这个值也不一定有，因为不是所有人都会配置 JMETER_HOME 这个环境变量 * 其实从这边开始，大家就会发现，Jmeter 会经常使用 System.getProperty 来获取一些属性，在后面的代码中我们也会经常见到这样的代码 */ tmpDir = System.getProperty(&quot;jmeter.home&quot;, System.getenv(&quot;JMETER_HOME&quot;)); if (tmpDir == null || tmpDir.length() == 0) &#123; File userDir = new File(System.getProperty(&quot;user.dir&quot;)); tmpDir = userDir.getAbsoluteFile().getParent(); &#125; &#125; if (tmpDir == null) &#123; tmpDir = System.getenv(&quot;JMETER_HOME&quot;); &#125; JMETER_INSTALLATION_DIRECTORY = tmpDir; boolean usesUNC = OS_NAME_LC.startsWith(&quot;windows&quot;); StringBuilder classpath = new StringBuilder(); /** * 下面的几个目录大家就很眼熟了，就是 Jmeter 解压后，主目录下的文件夹，里面都是 Jmeter 可能用到的一些 jar 包 */ File[] libDirs = new File[] &#123; new File(JMETER_INSTALLATION_DIRECTORY + File.separator + &quot;lib&quot;), new File(JMETER_INSTALLATION_DIRECTORY + File.separator + &quot;lib&quot; + File.separator + &quot;ext&quot;), new File(JMETER_INSTALLATION_DIRECTORY + File.separator + &quot;lib&quot; + File.separator + &quot;junit&quot;)&#125;; for (File libDir : libDirs) &#123; File[] libJars = libDir.listFiles((dir, name) -&gt; name.endsWith(&quot;.jar&quot;)); if (libJars == null) &#123; new Throwable(&quot;Could not access &quot; + libDir).printStackTrace(); continue; &#125; /** * 不晓得为啥要排个序 */ Arrays.sort(libJars); for (File libJar : libJars) &#123; try &#123; String s = libJar.getPath(); if (usesUNC) &#123; if (s.startsWith(&quot;\\\\\\\\&quot;) &amp;&amp; !s.startsWith(&quot;\\\\\\\\\\\\&quot;)) &#123; s = &quot;\\\\\\\\&quot; + s; &#125; else if (s.startsWith(&quot;//&quot;) &amp;&amp; !s.startsWith(&quot;///&quot;)) &#123; s = &quot;//&quot; + s; &#125; &#125; jars.add(new File(s).toURI().toURL()); classpath.append(CLASSPATH_SEPARATOR); classpath.append(s); &#125; catch (MalformedURLException e) &#123; EXCEPTIONS_IN_INIT.add(new Exception(&quot;Error adding jar:&quot;+libJar.getAbsolutePath(), e)); &#125; &#125; &#125; System.setProperty(JAVA_CLASS_PATH, initiaClasspath + classpath.toString()); /** * 类加载器会加载扫描到的这些 jar 包，为 Jmeter 真正启动做好准备 */ loader = AccessController.doPrivileged( (PrivilegedAction&lt;DynamicClassLoader&gt;) () -&gt; new DynamicClassLoader(jars.toArray(new URL[jars.size()])) ); &#125;&#125; 从上面的代码中，我们可以看到，NewDriver 在实例化时，会执行一个静态代码块，主要作用就是加载 Jmeter 安装目录下的 jar 包。 Main方法介绍下面介绍 NewDriver 的 main 方法，这个方法就是整个 Jmeter 启动的入口方法。 1234567891011121314151617181920212223242526272829303132333435363738394041public static void main(String[] args) &#123; /** * 检查初始化是不是报错了 */ if(!EXCEPTIONS_IN_INIT.isEmpty()) &#123; System.err.println(&quot;Configuration error during init, see exceptions:&quot;+exceptionsToString(EXCEPTIONS_IN_INIT)); &#125; else &#123; /** * 设置当前线程的类加载器，也就是 Jmeter 自己写的那个动态类加载器 */ Thread.currentThread().setContextClassLoader(loader); /** * 配置一些日志属性，不重要 */ setLoggingProperties(args); try &#123; /** * 判断要不要用 GUI 模式启动，默认 true，也可以通过 Jmeter 命令行参数 -n 来指定使用非 GUI 模式启动 */ if(System.getProperty(HEADLESS_MODE_PROPERTY) == null &amp;&amp; shouldBeHeadless(args)) &#123; System.setProperty(HEADLESS_MODE_PROPERTY, &quot;true&quot;); &#125; /** * 获取 Jmeter 类，作用类似于 Class.forName(String clazzName) */ Class&lt;?&gt; initialClass = loader.loadClass(&quot;org.apache.jmeter.JMeter&quot;); /** * 获取 Jmeter 实例 */ Object instance = initialClass.getDeclaredConstructor().newInstance(); /** * 获取 Jmeter.start方法，并调用 */ Method startup = initialClass.getMethod(&quot;start&quot;, new Class[] &#123; new String[0].getClass() &#125;); startup.invoke(instance, new Object[] &#123; args &#125;); &#125; catch(Throwable e)&#123; e.printStackTrace(); System.err.println(&quot;JMeter home directory was detected as: &quot;+JMETER_INSTALLATION_DIRECTORY); &#125; &#125; &#125; main 方法其实很简单直接，就是看下是不是要启动 GUI，然后就是通过反射调用 Jmeter 的 start 方法，来开始测试。综上，NewDriver 其实就是一个启动器，正如其所在源码模块 launcher 一样，他的作用就是为 Jmeter 真正启动做好准备。好了，NewDriver 就介绍完了，下一章将介绍 Jmeter 这个核心类，以及调用其 start(String[] args) 之后会发生什么…","categories":[],"tags":[{"name":"Jmeter源码系列","slug":"Jmeter源码系列","permalink":"https://linvaux.github.io/tags/Jmeter%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"}]},{"title":"Jdk11获取系统信息","slug":"Jdk11获取系统信息","date":"2024-07-26T14:01:20.000Z","updated":"2024-07-26T14:02:01.734Z","comments":true,"path":"2024/07/26/Jdk11获取系统信息/","permalink":"https://linvaux.github.io/2024/07/26/Jdk11%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/","excerpt":"","text":"下面用到的 api 仅在 jdk11 上测试通过，其他 jdk 版本没试过 工具类 SystemInfoUtils.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import com.demo.constant.SystemInfoConstant;import com.sun.management.OperatingSystemMXBean;import lombok.extern.slf4j.Slf4j;import java.lang.management.ManagementFactory;import java.net.InetAddress;import java.net.NetworkInterface;import java.nio.file.*;import java.text.DecimalFormat;import java.util.ArrayList;import java.util.Enumeration;import java.util.List;import java.util.stream.Collectors;/** * @description: 系统信息工具类 */@Slf4jpublic class SystemInfoUtils &#123; /** * 获取本地IP地址 * @return 本机 ip，过滤了回环地址和 localhost */ public static List&lt;String&gt; getLocalIP() &#123; List&lt;String&gt; ipList = new ArrayList&lt;&gt;(); try &#123; // 获取本地所有网络接口 Enumeration&lt;NetworkInterface&gt; networkInterfaces = NetworkInterface.getNetworkInterfaces(); while (networkInterfaces.hasMoreElements()) &#123; NetworkInterface networkInterface = networkInterfaces.nextElement(); // 排除虚拟接口和未启用的接口 if (networkInterface.isVirtual() || !networkInterface.isUp()) &#123; continue; &#125; Enumeration&lt;InetAddress&gt; inetAddresses = networkInterface.getInetAddresses(); while (inetAddresses.hasMoreElements()) &#123; InetAddress inetAddress = inetAddresses.nextElement(); if (!inetAddress.isLinkLocalAddress()) &#123; ipList.add(inetAddress.getHostAddress()); &#125; &#125; &#125; &#125; catch (Exception e) &#123; log.error(&quot;本机 IP 获取失败, 异常详情: &quot; + ExceptionUtil.getErrorMessage(e)); &#125; return ipList.stream().filter(e -&gt; !SystemInfoConstant.INVALID_IP_LIST.contains(e)).collect(Collectors.toList()); &#125; /** * 获取CPU数量 * @return 逻辑处理器数量，物理核数 * 2 */ public static int getCpuCount() &#123; // 此处有坑，OperatingSystemMXBean 存在于两个包：java.lang.management.OperatingSystemMXBean 和 com.sun.management.OperatingSystemMXBean // 一定要找对包，不然有些方法找不到，太特么坑了 java.lang.management.OperatingSystemMXBean operatingSystemMXBean = ManagementFactory.getOperatingSystemMXBean(); return operatingSystemMXBean.getAvailableProcessors(); &#125; /** * 获取总内存大小 * @return 物理内存大小 */ public static String getTotalPhysicalMemory() &#123; OperatingSystemMXBean osBean = ManagementFactory.getPlatformMXBean(OperatingSystemMXBean.class); long physicalMemorySize = osBean.getTotalPhysicalMemorySize(); double physicalMemoryGB = (double) physicalMemorySize / 1024 / 1024 / 1024; DecimalFormat decimalFormat = new DecimalFormat(&quot;#.##&quot;); return decimalFormat.format(physicalMemoryGB) + &quot;GB&quot;; &#125; /** * 获取磁盘总大小 * @return 磁盘总量 */ public static String getDiskSizeTotal() &#123; String diskSize = null; try &#123; Path rootDir = Paths.get(&quot;/&quot;); FileStore store = Files.getFileStore(rootDir); long totalSpace = store.getTotalSpace(); double totalGB = (double) totalSpace / 1024 / 1024 / 1024; DecimalFormat decimalFormat = new DecimalFormat(&quot;#.##&quot;); diskSize = decimalFormat.format(totalGB + &quot;GB&quot;); &#125; catch (Exception e) &#123; log.error(&quot;磁盘信息获取失败, 异常详情: &#123;&#125;&quot;, ExceptionUtil.getErrorMessage(e)); &#125; return diskSize; &#125; /** * 获取已使用磁盘大小 * @return 磁盘已使用量 */ public static String getDiskSizeUsed() &#123; String diskSize = null; try &#123; Path rootDir = Paths.get(&quot;/&quot;); FileStore store = Files.getFileStore(rootDir); long usableSpace = store.getUsableSpace(); double usableGB = (double) usableSpace / 1024 / 1024 / 1024; DecimalFormat decimalFormat = new DecimalFormat(&quot;#.##&quot;); diskSize = decimalFormat.format(usableGB + &quot;GB&quot;); &#125; catch (Exception e) &#123; log.error(&quot;磁盘信息获取失败, 异常详情: &#123;&#125;&quot;, ExceptionUtil.getErrorMessage(e)); &#125; return diskSize; &#125; /** * 获取可用磁盘大小 * @return 磁盘可使用量 */ public static String getDiskSizeFree() &#123; String diskSize = null; try &#123; Path rootDir = Paths.get(&quot;/&quot;); FileStore store = Files.getFileStore(rootDir); long freeSpace = store.getUnallocatedSpace(); double freeGB = (double) freeSpace / 1024 / 1024 / 1024; DecimalFormat decimalFormat = new DecimalFormat(&quot;#.##&quot;); diskSize = decimalFormat.format(freeGB + &quot;GB&quot;); &#125; catch (Exception e) &#123; log.error(&quot;磁盘信息获取失败, 异常详情: &#123;&#125;&quot;, ExceptionUtil.getErrorMessage(e)); &#125; return diskSize; &#125;&#125; 常量类 SystemInfoConstant.java1234567891011121314151617181920212223242526import java.util.List;/** * @description: 系统信息常量 */public class SystemInfoConstant &#123; /** * ipv4 回环地址 */ public static final String IPV4_LOOP_ADDRESS = &quot;0.0.1.1&quot;; /** * ipv6 回环地址 */ public static final String IPV6_LOOP_ADDRESS = &quot;0:0:0:0:0:0:0:1%lo0&quot;; /** * 本机 IP */ public static final String LOCAL_HOST = &quot;127.0.0.1&quot;; /** * 无效的 ip 地址列表，需要排除 */ public static final List&lt;String&gt; INVALID_IP_LIST = List.of(IPV4_LOOP_ADDRESS, IPV6_LOOP_ADDRESS, LOCAL_HOST); 异常信息获取工具类 ExceptionUtil.java123456789101112131415161718192021222324252627282930import org.springframework.util.StringUtils;import java.io.PrintWriter;import java.io.StringWriter;/** * @description: 异常工具类 */public class ExceptionUtil &#123; /** * 异常信息允许的最大长度，超过这个长度会被截取 */ private static final Integer ERROR_MSG_MAX_LENGTH = 2000; /** * 获取异常的堆栈信息 * * @param e 异常对象 * @return 堆栈信息 */ public static String getErrorMessage(Exception e) &#123; if (StringUtils.hasText(e.getMessage())) &#123; return e.getMessage(); &#125; StringWriter sw = new StringWriter(); e.printStackTrace(new PrintWriter(sw, Boolean.TRUE)); String message = sw.toString(); return message.length() &gt; ERROR_MSG_MAX_LENGTH ? message.substring(0, ERROR_MSG_MAX_LENGTH) : message; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://linvaux.github.io/tags/Java/"}]},{"title":"IDEA高效使用指南(一)","slug":"IDEA高效使用指南（一）","date":"2024-07-26T13:48:42.000Z","updated":"2024-07-26T13:49:51.460Z","comments":true,"path":"2024/07/26/IDEA高效使用指南（一）/","permalink":"https://linvaux.github.io/2024/07/26/IDEA%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"设置全局 JDK File -&gt; New Projects Setup -&gt; Structure… Maven 配置 Perferences -&gt; Build,Execution,Deployment -&gt; Build Tools -&gt; Maven 自动导包&#x2F;删除无用包 Perferences -&gt; Editor -&gt; General -&gt; Auto Import 注释模板 Perferences -&gt; Editor -&gt; File and Code Templates class 注释模板示例 123456789#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != &quot;&quot;)package $&#123;PACKAGE_NAME&#125;;#end#parse(&quot;File Header.java&quot;)/** * @author: $&#123;USER&#125; * @date: $&#123;DATE&#125; $&#123;TIME&#125; * @description: */public class $&#123;NAME&#125; &#123;&#125; 显示方法分割线 Perferences -&gt; Editor -&gt; General -&gt; Appearance 代码自动补全 Perferences -&gt; Editor -&gt; General -&gt; Code Completion 设置每行代码最大长度 Perferences -&gt; Editor -&gt; Code Style 阿里巴巴的 Java 开发规范推荐每行长度不要超过 120，但是我习惯用 200 修改注释颜色 Perferences -&gt; Editor -&gt; Color Scheme -&gt; Java 去掉Inherit values from 前面的√，选中 Foreground 自己设置个喜欢的颜色 这是我现在的配置 Line comment: FFB704, Text: 02FA15 禁止 IDEA 启动时，自动打开上一个项目 Perperences -&gt; Appearance &amp; Behavior -&gt; System Settings 修改字体 Perferences -&gt; Editor -&gt; Font 我习惯使用 Consolas 字体，但是 mac 上默认没有这个字体，需要自行安装: http://www.fontpalace.com/font-details/Consolas/ 修改文件编码 Perferences -&gt; Editor -&gt; File Encodings 直接使用 UTF-8 编码即可，如果出现乱码，记得勾选下面的 Transparent native-to-ascii conversion 修改 IDEA 的 JVM 堆配置 IDEA 默认的堆配置貌似是 750MB，启动一个大型项目时，这点内存不大够用，可以自己通过如下配置修改 help -&gt; Edit custom VM options 修改配置 -Xmx8192m, 按照自己电脑内存大小配置 窗口多标签换行显示 Perferences -&gt; Editor -&gt; General -&gt; Editor Tabs 标识修改过的文件 Perferences -&gt; Editor -&gt; General -&gt; Editor Tabs 实现 Serializable 接口时，提示生成 SerialVersionUID Perferences -&gt; Editor -&gt; Inspections 在实现了 Serializable 接口的类上使用快捷键 alt+enter,就会提示生成 SerialVersionUID","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://linvaux.github.io/tags/IDEA/"}]},{"title":"Centos使用Tomcat安装Jenkins","slug":"Centos使用Tomcat安装Jenkins","date":"2024-07-26T13:47:23.000Z","updated":"2024-07-26T13:47:37.870Z","comments":true,"path":"2024/07/26/Centos使用Tomcat安装Jenkins/","permalink":"https://linvaux.github.io/2024/07/26/Centos%E4%BD%BF%E7%94%A8Tomcat%E5%AE%89%E8%A3%85Jenkins/","excerpt":"","text":"安装步骤安装JDK1.812yum makecacheyum install -y java-1.8.0-openjdk.x86_64 安装tomcat1234567# 下载tomcat9.0wget https://mirrors.bfsu.edu.cn/apache/tomcat/tomcat-9/v9.0.36/bin/apache-tomcat-9.0.36.tar.gz &amp;&amp; tar -xvf apache-tomcat-9.0.36.tar.gz# 删除webapps下面的项目cd apache-tomcat-9.0.36/webapps/ &amp;&amp; rm -rf *# 下载jenkins.war并重命名为ROOT.warwget https://mirrors.huaweicloud.com/jenkins/war/2.240/jenkins.war -O ROOT.war 修改Tomcat启动脚本，支持Jenkins跨域12345# 修改bin/catalina.sh,在首行添加如下参数export CATALINA_OPTS=&quot;-Djava.awt.headless=true&quot;export JAVA_OPTS=&quot;-Dhudson.model.DirectoryBrowserSupport.CSP= &quot;# 启动tomcat./startup.sh 关闭防火墙12systemctl stop firewalldsystemctl disable firewalld 访问jenkins tomcat默认监听端口是8080，访问 192.168.1.2:8080 如果jenkins启动页面可以正常打开，此时，停止tomcat，并修改jenkins配置。 12bash &lt;tomcat安装目录&gt;/bin/shutdown.shcd ~/.jenkins/ 找到hudson.model.UpdateCenter.xml文件，修改为如下内容 1234567&lt;?xml version=&#x27;1.1&#x27; encoding=&#x27;UTF-8&#x27;?&gt;&lt;sites&gt; &lt;site&gt; &lt;id&gt;default&lt;/id&gt; &lt;url&gt;https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json&lt;/url&gt; &lt;/site&gt;&lt;/sites&gt; 启动tomcat jenkins启动后，需要输入初始化密码，根据页面提示填写密码后，进入插件安装页面，此时，需要再次停止tomcat，然后执行以下命令，更换jenkins更新源之后，再次启动tomcat。 123cd ~/.jenkins/updates;sed -i &#x27;s/http:\\/\\/updates.jenkins-ci.org\\/download/https:\\/\\/mirrors.tuna.tsinghua.edu.cn\\/jenkins/g&#x27; default.json &amp;&amp; sed -i &#x27;s/http:\\/\\/www.google.com/https:\\/\\/www.baidu.com/g&#x27; default.json;bash &lt;tomcat安装目录&gt;/bin/startup.sh 此时，jenkins会要求重新输入初始化密码，然后选择安装建议的插件，等待安装完成。 插件安装完成后，需要设置管理员信息，之后进入jenkins工作页面。 jenkins常用插件 chinese （汉化） locale（汉化） blue ocean（流水线工具） Allure Jenkins Plugin (allure报告) Extended Choice Parameter Plug-In (参数化构建扩展) AnsiColor （日志彩色输出） Git Parameter Plug-In（代码分支选择） build failure analyzer (构建失败分析) multijob（组织多job构建） multiple SCMs （设置多个git） simple theme（jenkins主题 http://afonsof.com/jenkins-material-theme/） merge request event (gitlab 代码门禁) SLOCCount Plug-in（clco代码量统计结果展示） Warnings Next Generation Plugin（代码静态扫描结果展示 https://github.com/jenkinsci/warnings-ng-plugin/blob/master/SUPPORTED-FORMATS.md） Jacoco（java代码覆盖率报告） Html publisher（生成html报告） backup（备份&#x2F;恢复jenkins） Gitlab（gitlab支持插件） Gitee（gitee支持插件） Role-based Authorization Strategy (角色权限控制) Active Choices (根据所选参数，自动调出对应参数所依赖的后续参数) Job Configuration History (配置记录管理，支持配置回滚)","categories":[],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://linvaux.github.io/tags/Jenkins/"}]},{"title":"Springboot业务信息国际化","slug":"Springboot业务信息国际化","date":"2024-07-26T13:43:49.000Z","updated":"2024-07-26T13:46:30.462Z","comments":true,"path":"2024/07/26/Springboot业务信息国际化/","permalink":"https://linvaux.github.io/2024/07/26/Springboot%E4%B8%9A%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%9B%BD%E9%99%85%E5%8C%96/","excerpt":"","text":"业务背景用户上传一个 excel 文件，要对 excel 内容做校验，然后返回校验结果。校验通过之后，在执行导入。但是现在平台要做国际化，支持中英双语，目前校验结果是直接中文返回，为了完成国际化需求，需要根据请求头中的 Accept-language 来决定返回何种语言的内容。 当前处理方式 国际化方案使用工具类获取国际化内容1234567891011121314151617181920212223242526272829303132333435363738394041import org.springframework.context.MessageSource;import org.springframework.context.MessageSourceAware;import org.springframework.context.support.MessageSourceAccessor;import org.springframework.stereotype.Component;@Componentpublic class I18nMessageUtil implements MessageSourceAware &#123; private static MessageSourceAccessor accessor; /** * 获取i18n文件中对应的国际化信息 * * @param code i18n文件中code * @param locale 地区信息 * @param args 参数 * @return 国际化信息 */ public static String getMessage(String code, Locale locale, Object... args) &#123; if (locale == null) &#123; return accessor.getMessage(code, args); &#125; return accessor.getMessage(code, args, locale); &#125; /** * 获取i18n文件中对应的国际化信息,如果不传locale信息，则从当前request获取，如果还是没有，则使用默认locale * * @param code i18n文件中code * @param args 参数 * @return 国际化信息 */ public static String getMessage(String code, Object... args) &#123; return accessor.getMessage(code, args); &#125; @Override public void setMessageSource(MessageSource messageSource) &#123; I18nMessageUtil.accessor = new MessageSourceAccessor(messageSource); &#125;&#125; 配置国际化文件12345678910111213141516171819202122232425import org.springframework.context.MessageSource;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.support.ResourceBundleMessageSource;import java.util.HashSet;import java.util.Set;@Configurationpublic class I18nConfig &#123; @Bean public MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); Set&lt;String&gt; i18nFolder = new HashSet&lt;&gt;(); // excel 校验的国际化文件 i18nFolder.add(&quot;i18n.excelValidation&quot;); // 默认的国际化文件 i18nFolder.add(&quot;i18n.messages&quot;); messageSource.setBasenames(i18nFolder.toArray(new String[0])); messageSource.setDefaultEncoding(&quot;UTF-8&quot;); messageSource.setUseCodeAsDefaultMessage(true); return messageSource; &#125;&#125; 编写国际化异常信息 替换校验异常信息","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://linvaux.github.io/tags/SpringBoot/"}]},{"title":"FileBeat+LogStash实现MySQL慢查询日志解析","slug":"FileBeat-LogStash实现MySQL慢查询日志解析","date":"2024-07-26T13:42:18.000Z","updated":"2024-07-26T13:43:16.162Z","comments":true,"path":"2024/07/26/FileBeat-LogStash实现MySQL慢查询日志解析/","permalink":"https://linvaux.github.io/2024/07/26/FileBeat-LogStash%E5%AE%9E%E7%8E%B0MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E8%A7%A3%E6%9E%90/","excerpt":"","text":"背景是一个大型营销系统经常出现mysql的慢查询，导致线上服务频繁出现故障，为了查看是哪些sql有问题，并且要支持各种维度的统计查询，所以使用FileBeat+LogStash+ElasticSearch+Kibana实现此需求。本文仅描述如何配置FileBeath和LogStash实现MySQL慢查询日志解析。 FileBeat配置12345678910111213141516171819filebeat.inputs:- type: log enabled: true # 忽略在指定的时间跨度之前被修改的文件 ignore_older: 30000h # mysql慢查询日志目录，支持*通配符匹配多级目录 paths: - /opt/slow-sql/*.log # 文档类型是mysqlslow，这是filebeat内置的一套规则 document_type: mysqlslow multiline: pattern: &quot;^# User@Host: &quot; negate: true match: after tail_files: falseoutput.logstash: # logstash的地址，我是部署在同一台机器上的 hosts: [&quot;127.0.0.1:5044&quot;] LogStash配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556input &#123; # 使用filebeat推送日志 beats &#123; port =&gt; 5044 host =&gt; &quot;0.0.0.0&quot; &#125;&#125;filter &#123; grok &#123; # 有数据库名，有schema match =&gt; &#123;&quot;message&quot; =&gt; &quot;(?m)^# User@Host: %&#123;USER:user&#125;\\[[^\\]]+\\]\\s@\\s*\\[%&#123;IP:clientip&#125;\\]\\s*([\\s\\S]*)#\\s+Schema: (?&lt;schema&gt;\\w+)([\\s\\S]*)\\s+#\\s+Query_time:\\s+%&#123;NUMBER:query_time:float&#125;\\s+Lock_time: %&#123;NUMBER:lock_time:float&#125;\\s+Rows_sent: %&#123;NUMBER:rows_sent:int&#125;\\s+Rows_examined: %&#123;NUMBER:rows_examined:int&#125;\\s*([\\s\\S]*)use\\s(?&lt;dbname&gt;\\w+);([\\s\\S]*)SET timestamp=%&#123;NUMBER:sql_time:int&#125;&quot;&#125; # 无数据库名,有schema match =&gt; &#123;&quot;message&quot; =&gt; &quot;(?m)^# User@Host: %&#123;USER:user&#125;\\[[^\\]]+\\]\\s@\\s*\\[%&#123;IP:clientip&#125;\\]\\s*([\\s\\S]*)#\\s+Schema: (?&lt;schema&gt;\\w+)([\\s\\S]*)\\s+#\\s+Query_time:\\s+%&#123;NUMBER:query_time:float&#125;\\s+Lock_time: %&#123;NUMBER:lock_time:float&#125;\\s+Rows_sent: %&#123;NUMBER:rows_sent:int&#125;\\s+Rows_examined: %&#123;NUMBER:rows_examined:int&#125;\\s*([\\s\\S]*)SET timestamp=%&#123;NUMBER:sql_time:int&#125;&quot;&#125; # 有数据库名，无schema match =&gt; &#123;&quot;message&quot; =&gt; &quot;(?m)^# User@Host: %&#123;USER:user&#125;\\[[^\\]]+\\]\\s@\\s*\\[%&#123;IP:clientip&#125;\\]\\s*([\\s\\S]*)#\\s+Query_time:\\s+%&#123;NUMBER:query_time:float&#125;\\s+Lock_time: %&#123;NUMBER:lock_time:float&#125;\\s+Rows_sent: %&#123;NUMBER:rows_sent:int&#125;\\s+Rows_examined: %&#123;NUMBER:rows_examined:int&#125;\\s*([\\s\\S]*)use\\s(?&lt;dbname&gt;\\w+);([\\s\\S]*)SET timestamp=%&#123;NUMBER:sql_time:int&#125;&quot;&#125; # 无数据库名,无schema match =&gt; &#123;&quot;message&quot; =&gt; &quot;(?m)^# User@Host: %&#123;USER:user&#125;\\[[^\\]]+\\]\\s@\\s*\\[%&#123;IP:clientip&#125;\\]\\s*([\\s\\S]*)#\\s+Query_time:\\s+%&#123;NUMBER:query_time:float&#125;\\s+Lock_time: %&#123;NUMBER:lock_time:float&#125;\\s+Rows_sent: %&#123;NUMBER:rows_sent:int&#125;\\s+Rows_examined: %&#123;NUMBER:rows_examined:int&#125;\\s*([\\s\\S]*)SET timestamp=%&#123;NUMBER:sql_time:int&#125;&quot;&#125; overwrite =&gt; [&quot;message&quot;] &#125; grok&#123; # 匹配 source中的ip match =&gt; &#123;&quot;source&quot; =&gt; &quot;(?m)\\s*%&#123;IP:server_ip&#125;&quot;&#125; &#125; # 时间戳格式化并只保留日期 ruby &#123; code =&gt; &quot; require &#x27;time&#x27; event.set(&#x27;date_tag&#x27;, Time.at(event.get(&#x27;sql_time&#x27;)).to_date.to_s.delete!(&#x27;-&#x27;)) &quot; &#125; # 索引时间戳使用sql生成的时间，不再使用当前时间 date &#123; match =&gt; [&quot;sql_time&quot;, &quot;yyyy-MM-dd HH:mm:ss&quot;, &quot;UNIX&quot;] target =&gt; &quot;@timestamp&quot; locale =&gt; &quot;cn&quot; &#125;&#125;output &#123; # 调试时使用，在控制台打印日志分割结果 stdout &#123; codec =&gt; rubydebug &#123;&#125; &#125; # es配置 elasticsearch &#123; hosts =&gt; &quot;localhost:9200&quot; # 索引名称 index =&gt; &quot;slow-sql-%&#123;+YYYY.MM.dd&#125;&quot; &#125; &#125; 一键安装ELFK123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#!/bin/bashecho &quot;#-----------------------------------------#@Author: linvaux #@Email: linvaux@outlook.com#@Desc: Auto install ELFK#----------------------------------------&quot;INFO()&#123; echo -e &quot;\\033[0;32m[INFO] $* \\033[0m&quot;&#125;ERROR()&#123; echo -e &quot;\\033[0;31m[ERROR] $* \\033[0m&quot;&#125;WARN()&#123; echo -e &quot;\\033[0;33m[WARN] $* \\033[0m&quot;&#125;# booster the docker-hubbooster()&#123; daemon=&quot;/etc/docker/daemon.json&quot; if [[ -e $&#123;daemon&#125; ]];then INFO Backup $&#123;daemon&#125; success! mv $&#123;daemon&#125; $&#123;daemon&#125;.bak echo &quot;&#123;\\&quot;registry-mirrors\\&quot; : [\\&quot;https://hub-mirror.c.163.com\\&quot;]&#125;&quot; &gt; $&#123;daemon&#125; else echo &quot;&#123;\\&quot;registry-mirrors\\&quot; : [\\&quot;https://hub-mirror.c.163.com\\&quot;]&#125;&quot; &gt; $&#123;daemon&#125; fi INFO Config docker-hub booster success!&#125;check_env()&#123; if [[ -z &quot;$(which docker)&quot; ]] then WARN No docker were found,try to install! INFO Start to install docker source /etc/os-release if [[ &quot;$ID&quot; == &quot;ubuntu&quot; ]] || [[ &quot;$ID&quot; == &quot;debain&quot; ]] then apt update apt install curl wget -y curl -fsSL https://get.docker.com | sh booster systemctl daemon-reload systemctl restart docker if [[ -z &quot;$(which java)&quot; ]];then apt install openjdk-8-jdk -y fi elif [[ &quot;$ID&quot; == &quot;centos&quot; ]] then yum update -y yum install wget curl net-tools -y curl -fsSL https://get.docker.com | sh booster systemctl daemon-reload systemctl restart docker if [[ -z &quot;$(which java)&quot; ]];then yum install java-1.8.0-openjdk -y fi else ERROR Could not support $ID platform! exit 1 fi fi&#125;install_elasticsearch()&#123; INFO Start to install elasticsearch echo &quot;vm.max_map_count=655360&quot; &gt;&gt; /etc/sysctl.conf sysctl -p docker pull docker.elastic.co/elasticsearch/elasticsearch:6.5.4 docker run -d --restart=always -p 9200:9200 -p 9300:9300 --name es -h es -e cluster.name=kiki -e node.name=node1 -e http.cors.enabled=true -e http.cors.allow-origin=&quot;*&quot; -e xpack.security.enabled=false docker.elastic.co/elasticsearch/elasticsearch:6.5.4&#125;install_kibana()&#123; INFO Start to install kibana docker pull kibana:6.5.4; docker run --restart=always -p 5601:5601 --name kibana -e ELASTICSEARCH_URL=http://127.0.0.1:9200 --network=host -d kibana:6.5.4&#125;install_filebeat_and_logstash()&#123; INFO Start to install filebeat and logstash source /etc/os-release if [[ &quot;$ID&quot; == &quot;ubuntu&quot; ]] || [[ &quot;$ID&quot; == &quot;debain&quot; ]] then wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add - apt-get install apt-transport-https -y echo &quot;deb https://artifacts.elastic.co/packages/6.x/apt stable main&quot; | sudo tee -a /etc/apt/sources.list.d/elastic-6.x.list apt-get update &amp;&amp; apt install filebeat logstash -y if [[ $? -ne 0 ]] then ERROR Install filebeat and logstash failed! exit 1 fi elif [[ &quot;$ID&quot; == &quot;centos&quot; ]] then rpm --import https://packages.elastic.co/GPG-KEY-elasticsearch echo -e &#x27;[elastic-6.x]name=Elastic repository for 6.x packagesbaseurl=https://artifacts.elastic.co/packages/6.x/yumgpgcheck=1gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearchenabled=1autorefresh=1type=rpm-md&#x27; &gt; /etc/yum.repos.d/elastic.io.repo yum makecache &amp;&amp; yum install filebeat logstash -y if [[ $? -ne 0 ]] then ERROR Install filebeat and logstash failed! exit 1 fi else ERROR Could not support $ID platform! exit 1 fi&#125;start_filebeat()&#123; INFO Start to call filebeat filebeat_yaml=&quot;/etc/filebeat/filebeat.yml&quot; if [[ -f $&#123;filebeat_yaml&#125; ]];then mv $&#123;filebeat_yaml&#125; $&#123;filebeat_yaml&#125;.bak cp ./filebeat.yml $&#123;filebeat_yaml&#125; systemctl restart filebeat if [[ $? -ne 0 ]] then ERROR Start filebeat failed! exit 1 fi else ERROR $&#123;filebeat_yaml&#125; not found, please check! exit 1 fi&#125;start_logstash()&#123; INFO Start to call logstash logstash_conf_dir=&quot;/etc/logstash/conf.d/&quot; if [[ -e $&#123;logstash_conf_dir&#125; ]];then cp ./slow_sql_by_query.conf $&#123;logstash_conf_dir&#125; systemctl restart logstash if [[ $? -ne 0 ]] then ERROR Start logstash failed! exit 1 fi else ERROR $&#123;logstash_conf_dir&#125; not found, please check! exit 1 fi&#125;run()&#123; if [[ &quot;root&quot; == $(whoami) ]] then INFO Start to run... check_env install_elasticsearch install_kibana install_filebeat_and_logstash # download_log start_logstash start_filebeat # check_index INFO Run success! else ERROR Run as root please! fi&#125;run","categories":[],"tags":[{"name":"LogStash","slug":"LogStash","permalink":"https://linvaux.github.io/tags/LogStash/"}]},{"title":"EasyExcel解决自定义样式太多导致的 The maximum number of Cell Styles was exceeded 异常","slug":"EasyExcel解决自定义样式太多导致的-The-maximum-number-of-Cell-Styles-was-exceeded-异常","date":"2024-07-26T13:38:50.000Z","updated":"2024-07-26T13:41:07.071Z","comments":true,"path":"2024/07/26/EasyExcel解决自定义样式太多导致的-The-maximum-number-of-Cell-Styles-was-exceeded-异常/","permalink":"https://linvaux.github.io/2024/07/26/EasyExcel%E8%A7%A3%E5%86%B3%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F%E5%A4%AA%E5%A4%9A%E5%AF%BC%E8%87%B4%E7%9A%84-The-maximum-number-of-Cell-Styles-was-exceeded-%E5%BC%82%E5%B8%B8/","excerpt":"","text":"之前使用自定义样式解决了导出excel时，对不同单元格使用不同样式的需求，但是最近发现，导出大量数据时，就会产生如下异常 1java.lang.IllegalStateException: The maximum number of Cell Styles was exceeded. You can define up to 64000 style in a .xlsx Workbook 通过查看easyexcel在github上的issue可以发现，有很多人都出现了类似问题，原因是EasyExcel最多支持创建64000个样式对象。但是我写入的数据远远超过了64000，每次写入数据都会去创建一次样式对象，导致生成excel失败。错误的代码如下： 1234567891011121314151617181920public class CustomCellWriteHandler implements CellWriteHandler &#123; /** * 设置拦截器顺序，需要 &gt; 50000 * * @return 拦截器顺序 */ @Override public int order() &#123; return 60000; &#125; @Override public void afterCellDispose(CellWriteHandlerContext context) &#123; Cell cell = context.getCell(); if (BooleanUtils.isNotTrue(context.getHead())) &#123; Workbook workbook = context.getWriteWorkbookHolder().getWorkbook(); // 此处代码有问题，每次进入条件，都会重复创建一个XSSFCellStyle对象 XSSFCellStyle cellStyle = (XSSFCellStyle) workbook.createCellStyle(); &#125;&#125; 解决此问题方法也比较简单，直接使用成员变量，不再重复创建对象。改造后的代码如下 123456789101112131415161718192021222324252627public class CustomCellWriteHandler implements CellWriteHandler &#123; XSSFCellStyle cellStyle; /** * 设置拦截器顺序，需要 &gt; 50000 * * @return 拦截器顺序 */ @Override public int order() &#123; return 60000; &#125; @Override public void afterCellDispose(CellWriteHandlerContext context) &#123; Cell cell = context.getCell(); if (BooleanUtils.isNotTrue(context.getHead())) &#123; Workbook workbook = context.getWriteWorkbookHolder().getWorkbook(); if (cellStyle == null) &#123; cellStyle = (XSSFCellStyle) workbook.createCellStyle(); &#125; cellStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND); &#125; &#125;&#125; 在创建新样式之前，判断下是不是已经有这个样式了，没有的话再创建，这样就避免了重复创建样式对象导致的异常。","categories":[],"tags":[{"name":"Java, EasyExcel","slug":"Java-EasyExcel","permalink":"https://linvaux.github.io/tags/Java-EasyExcel/"}]},{"title":"IDEA插件整理(一)","slug":"IDEA插件整理（一）","date":"2024-07-25T15:24:54.000Z","updated":"2024-07-25T15:38:47.895Z","comments":true,"path":"2024/07/25/IDEA插件整理（一）/","permalink":"https://linvaux.github.io/2024/07/25/IDEA%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"Atom Material Icons material风格图标库，装完之后页面就花里胡哨的，挺好看 Material Theme UI material风格主题，还是挺好看的 One Dark Theme 暗黑风格主题（推荐），主要是免费 Rainbow Brackets 彩虹括号 .ignore 生成各类.ignore文件，在创建git仓库的时候使用此插件格外方便 CodeGlance 代码缩略图，方便定位代码 Java Bean to Json 在bean上右键，即可将此bean复制为json格式，在构造请求时比较方便 maven-search maven&#x2F;gradle坐标搜索插件，贼好用，支持模糊搜索 Maven Helper 依赖冲突查看神器，也可以树状展示依赖关系 Mybatisx mybatis-plus团队出品的插件，支持从数据库表直接生成代码，包含基本CRUD功能，很方便 MyBatisCodeHelperPro 怎么说呢，就是很厉害，基本不用自己写代码了，但是收费 演示视频：https://www.bilibili.com/video/av50632948 使用文档：https://gejun123456.github.io/MyBatisCodeHelper-Pro/#/ MyBatis Log EasyPlus 格式化mybatis日志，很好用 SequenceDiagram 生成方法的时序图，非常有用官方文档：https://vanco.github.io/SequencePlugin/ PlantUML 时序图，类图绘制插件 Grep Console 由于Intellij idea不支持显示ascii颜色，grep-console插件能很好的解决这个问题，下面就以开发JavaEE项目中，结合Log4j配置多颜色日志输出功能。 GitToolBox git工具箱，可以显示当前代码分支和每一行代码提交人以及commit log Translation 翻译插件，再也不用去百度翻译了 RestfulToolkit 根据url直接跳转到对应的controller，比较好用，尤其是url多的时候，直接搜索url就可以了 Key promoter X 记性不好的可以试试，时间长了就能记住快捷键了 Statistic 项目信息统计 Git Commit Message Helper 帮助生成commit message","categories":[{"name":"工具分享","slug":"工具分享","permalink":"https://linvaux.github.io/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Java, IDEA","slug":"Java-IDEA","permalink":"https://linvaux.github.io/tags/Java-IDEA/"}]},{"title":"EasyExcel自定义字段导入","slug":"EasyExcel自定义字段导入","date":"2024-07-25T15:10:00.000Z","updated":"2024-07-25T15:10:32.847Z","comments":true,"path":"2024/07/25/EasyExcel自定义字段导入/","permalink":"https://linvaux.github.io/2024/07/25/EasyExcel%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E6%AE%B5%E5%AF%BC%E5%85%A5/","excerpt":"","text":"1.背景原先的导入功能只支持使用固定模板导入，模板格式如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Getter@Setter@ToStringpublic class TestCaseExcelData &#123; @ExcelProperty(value = &quot;所属功能模块&quot;) private String module; @ExcelProperty(value = &quot;用例编号&quot;) private String code; @NotBlank(message = &quot;必填项不能为空&quot;) @ExcelProperty(value = &quot;*用例名称&quot;) private String name; @NotBlank(message = &quot;必填项不能为空&quot;) @ExcelProperty(value = &quot;*优先级&quot;) private String caseLevel; @NotBlank(message = &quot;必填项不能为空&quot;) @ExcelProperty(value = &quot;*用例类型&quot;) private String caseType; @ExcelProperty(value = &quot;用例标签&quot;) private String tags; @ExcelProperty(value = &quot;前置条件&quot;) private String preSteps; @NotBlank(message = &quot;必填项不能为空&quot;) @ExcelProperty(value = &quot;*操作步骤/场景描述&quot;) private String stepDesc; @NotBlank(message = &quot;必填项不能为空&quot;) @ExcelProperty(value = &quot;*预期结果&quot;) private String expectResult; @ExcelProperty(value = &quot;关联需求类型&quot;) private String requirementType; @ExcelProperty(value = &quot;关联需求ID&quot;) private String requirementId; @ExcelProperty(value = &quot;用例版本&quot;) private String caseVersion;&#125; EasyExcel 导入监听器直接使用AnalysisEventListener 即可实现导入校验，校验规则较为复杂，不在此处展开。现在要求用户配置了自定义字段之后，还可以导入自定义字段，同时保留对固定字段的校验逻辑。因此原有的适用对象的监听器不再适用，需要使用无对象的方式做数据校验。 2.问题 EasyExcel 无对象方式的监听器是继承AnalysisEventListener&lt;Map&lt;Integer, String&gt;&gt;类，在重写了invoke() 方法后发现，入参是 Map&lt;Integer, String&gt; data，这就导致我无法对每一行数据按照原有的方式校验。 用户导入的模板列顺序是不固定的，因此也没法遍历 data 进行原有规则的校验。 3.解决方案3.1 解决思路 既然 invoke() 方法入参是 Map&lt;Integer, String&gt; data 这种数据结构，那能不能把这个 Map 中固定的字段转为一个 TestCaseExcelData 对象来处理？ 如果要转为一个对象，那怎么把 Map 中的数据跟对象的字段做映射？ 3.2 Map 转对象 Map&lt;Integer, String&gt; 是当前行的数据，其中 key 是当前行的列索引，value 是当前单元格的值，如果要转对象，首先得知道这个单元格对应的表头是什么，获取表头的方式很简单，直接在 listener 中定义一个 Map&lt;Integer, String&gt; headMap ,然后重写 invokeHeadMap(Map&lt;Integer, String&gt; headMap, AnalysisContext context) 方法，即可获取到表头。 取到表头之后，就可以在 invoke(Map&lt;Integer, String&gt; data, AnalysisContext context)方法中遍历data，根据此 map 的 key 来获取到当前单元格表头信息。代码如下：1234567@Overridepublic void invoke(Map&lt;Integer, String&gt; data, AnalysisContext context) &#123; data.forEach((index, value) -&gt; &#123; // 获取表头 String headName = headMap.get(index); &#125;); &#125; 取到了当前单元格的对应的表头之后，发现这个表头就是 TestCaseExcelData 类中属性上加的 @ExcelProperty(value &#x3D; “用例版本”) 注解中 value 属性的值，那就简单了，直接通过反射获取这个类所有表头和对应的属性，然后存到一个 Map&lt;Stirng, Field&gt; fieldStringMap 中就好了，这样就能通过表头获取到这个表头字段对应的类属性，为我们后面创建对象奠定了基础。代码如下：12345678Field[] fields = TestCaseExcelData.class.getDeclaredFields();for (Field field : fields) &#123; if (field.isAnnotationPresent(ExcelProperty.class)) &#123; ExcelProperty declaredAnnotation = field.getDeclaredAnnotation(ExcelProperty.class); String headValue = declaredAnnotation.value()[0]; this.fieldStringMap.put(headValue, field); &#125;&#125; 经过上面的几步操作，我们已经得到了如下的几个Map123456// 当前行的数据 &lt;列索引, 单元格值&gt;Map&lt;Integer, String&gt; data;// 表头的数据 &lt;列索引, 单元格值&gt;Map&lt;Integer, String&gt; headMap;// 实体对象表头和对应字段的数据 &lt;表头名称, 表头对应的属性&gt;Map&lt;Stirng, Field&gt; fieldStringMap; 后面的思路经很清晰了，遍历行数据Map&lt;Integer, String&gt; data ，通过 key 来确定当前单元格对应的表头，然后通过表头来获取实体类对应的属性，再通过反射来给这个属性赋值。代码如下：1234567891011121314151617181920212223242526272829303132@Overridepublic void invoke(Map&lt;Integer, String&gt; data, AnalysisContext context) &#123; // 创建实体对象 TestCaseExcelData rawData = new TestCaseExcelData(); try &#123; data.forEach((index, value) -&gt; &#123; // 获取到当前单元格的表头 String headName = headMap.get(index); // 根据表头获取实体类的属性 Field field = fieldStringMap.get(headName); try &#123; // 判断实体类是否有此属性 if (field != null) &#123; field.setAccessible(true); // 通过反射直接赋值 field.set(rawData, value); &#125; &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; // 解析自定义字段，只有系统配置的字段才会被缓存 List&lt;CustomFieldPO&gt; customFieldPOS = systemCustomFieldMap.get(headName); if (CollectionUtils.isNotEmpty(customFieldPOS)) &#123; customFieldMap.put(customFieldPOS.get(0).getFieldKey(), value); &#125; &#125;); // 固定字段校验 ExcelValidateHelper.validateEntity(rawData); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; &#125; 经过以上操作，我们成功的把一个 Map 转为了一个已知的对象，这样就跟通过对象导入一样了，后面校验的代码也无需再重复编写。 4. 其他最后，附上自定义模板校验表头的代码 12345678910111213141516171819@Overridepublic void invokeHeadMap(Map&lt;Integer, String&gt; headMap, AnalysisContext context) &#123; super.invokeHeadMap(headMap, context); // 限制文件行数不超过5000行 if (context.readSheetHolder().getApproximateTotalRowNumber() &gt; 5000) &#123; throw new ServiceException(CommonException.EXCEL_ROW_EXCEEDED); &#125; // 校验excel模版是否正确 ExcelImportUtil.validateHeadLoosely(headMap, this.dynamicCaseHeader.get(0)); this.headMap = headMap; Field[] fields = TestCaseExcelData.class.getDeclaredFields(); for (Field field : fields) &#123; if (field.isAnnotationPresent(ExcelProperty.class)) &#123; ExcelProperty declaredAnnotation = field.getDeclaredAnnotation(ExcelProperty.class); String headValue = declaredAnnotation.value()[0]; this.fieldStringMap.put(headValue, field); &#125; &#125; &#125; 1234567891011121314151617181920212223242526272829303132/** * 表头宽松校验 * &lt;p&gt;只校验表头是否存在模板中的字段&lt;/p&gt; * &lt;p&gt;不允许存在重复的表头&lt;/p&gt; * &lt;p&gt;导入文件中可以包含多余的列名&lt;/p&gt; * * @param headMap 实际读到的表头 * @param expectedHeadMapFiled 期望的表头 */public static void validateHeadLoosely(Map&lt;Integer, String&gt; headMap, List&lt;String&gt; expectedHeadMapFiled) &#123; try &#123; if (CollectionUtils.isEmpty(expectedHeadMapFiled) || MapUtils.isEmpty(headMap)) &#123; throw new ServiceException(CommonException.EXCEL_TEMPLATE_IS_NOT_CORRECT); &#125; // 移除没有内容的表头 headMap.entrySet().removeIf(entry -&gt; entry.getValue() == null); // 判断是否存在重复列 Collection&lt;String&gt; headValues = headMap.values(); Set&lt;String&gt; headValuesSet = new HashSet&lt;&gt;(headValues); if (headValues.size() != headValuesSet.size()) &#123; throw new ServiceException(CommonException.EXCEL_HEADS_DUPLICATED); &#125; // 判断模板字段是否都包含在表头里 for (String value : expectedHeadMapFiled) &#123; if (!headMap.containsValue(value)) &#123; throw new ServiceException(CommonException.EXCEL_TEMPLATE_IS_NOT_CORRECT); &#125; &#125; &#125; catch (Exception e) &#123; throw new ServiceException(&quot;Excel表头校验失败，异常详情：&quot; + ExceptionUtil.getErrorMessage(e)); &#125; &#125;","categories":[],"tags":[{"name":"Java, EasyExcel","slug":"Java-EasyExcel","permalink":"https://linvaux.github.io/tags/Java-EasyExcel/"}]},{"title":"EasyExcel自定义单元格样式","slug":"EasyExcel自定义单元格样式","date":"2024-07-25T15:09:03.000Z","updated":"2024-07-25T15:11:30.742Z","comments":true,"path":"2024/07/25/EasyExcel自定义单元格样式/","permalink":"https://linvaux.github.io/2024/07/25/EasyExcel%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%95%E5%85%83%E6%A0%BC%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"之前在开发系统的导出功能时需要对单元格增加不同的样式，过程有点曲折，记录一下以备后续用到 创建java项目，引入以下依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt; excel 导出代码 123456789101112131415try (ExcelWriter excelWriter = EasyExcel.write(filePath).build()) &#123; WriteSheet sheet = EasyExcel.writerSheet(&quot;自定义样式&quot;) // 设置表头 .head(ExportHeaderDTO.class) // 不使用默认样式 .useDefaultStyle(Boolean.FALSE) // 添加自定义单元格样式 .registerWriteHandler(new CustomCellWriteHandler()) // 添加单元格边框样式 .registerWriteHandler(CustomHorizontalCellStyleStrategy.cellBorder()) .build(); excelWriter.write(collect, sheet); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 自定义样式 CustomCellWriteHandler.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class CustomCellWriteHandler implements CellWriteHandler &#123; /** * 设置拦截器顺序，需要 &gt; 50000 * * @return 拦截器顺序 */ @Override public int order() &#123; return 60000; &#125; @Override public void afterCellDispose(CellWriteHandlerContext context) &#123; Cell cell = context.getCell(); if (BooleanUtils.isNotTrue(context.getHead())) &#123; Workbook workbook = context.getWriteWorkbookHolder().getWorkbook(); XSSFCellStyle cellStyle = (XSSFCellStyle) workbook.createCellStyle(); cellStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND); // 设置边框粗细 cellStyle.setBorderRight(BorderStyle.THIN); cellStyle.setBorderTop(BorderStyle.THIN); cellStyle.setBorderRight(BorderStyle.THIN); cellStyle.setBorderBottom(BorderStyle.THIN); // 设置边框颜色 cellStyle.setTopBorderColor(IndexedColors.BLACK.index); cellStyle.setBottomBorderColor(IndexedColors.BLACK.index); cellStyle.setLeftBorderColor(IndexedColors.BLACK.index); cellStyle.setRightBorderColor(IndexedColors.BLACK.index); cellStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND); // 水平居中 cellStyle.setAlignment(HorizontalAlignment.CENTER); // 垂直居中 cellStyle.setVerticalAlignment(VerticalAlignment.CENTER); Font font = workbook.createFont(); if (cell.getColumnIndex() == 1) &#123; // 设置字体颜色 font.setColor(IndexedColors.DARK_TEAL.index); cellStyle.setFont(font); // 设置单元格颜色 cellStyle.setFillForegroundColor(new XSSFColor(ColorConstant.CustomColor.PINK, CustomIndexedColorMap.fromColors(CTColors.Factory.newInstance()))); cell.setCellStyle(cellStyle); // 这里要把 WriteCellData的样式清空， 不然后面还有一个拦截器 FillStyleCellWriteHandler 默认会将 WriteCellStyle 设置到cell里面去 会导致自己设置的不一样（很关键） context.getFirstCellData().setWriteCellStyle(null); &#125; &#125; &#125;&#125; 边框样式 CustomHorizontalCellStyleStrategy.java 12345678910111213141516171819202122232425public class CustomHorizontalCellStyleStrategy extends HorizontalCellStyleStrategy &#123; @Override public int order() &#123; return 6500; &#125; /** * 设置单元格边框 * @return 样式策略 */ public static HorizontalCellStyleStrategy cellBorder() &#123; WriteCellStyle headWriteCellStyle = new WriteCellStyle(); headWriteCellStyle.setTopBorderColor(IndexedColors.BLACK.index); headWriteCellStyle.setBottomBorderColor(IndexedColors.BLACK.index); headWriteCellStyle.setLeftBorderColor(IndexedColors.BLACK.index); headWriteCellStyle.setRightBorderColor(IndexedColors.BLACK.index); headWriteCellStyle.setFillPatternType(FillPatternType.SOLID_FOREGROUND); WriteCellStyle contentWriteCellStyle = new WriteCellStyle(); contentWriteCellStyle.setBorderRight(BorderStyle.THIN); contentWriteCellStyle.setBorderTop(BorderStyle.THIN); contentWriteCellStyle.setBorderRight(BorderStyle.THIN); contentWriteCellStyle.setBorderBottom(BorderStyle.THIN); return new HorizontalCellStyleStrategy(headWriteCellStyle, contentWriteCellStyle); &#125;&#125;","categories":[],"tags":[{"name":"Java, EasyExcel","slug":"Java-EasyExcel","permalink":"https://linvaux.github.io/tags/Java-EasyExcel/"}]},{"title":"基于Centos7的UI自动化环境Dockerfile","slug":"基于Centos7的UI自动化环境Dockerfile","date":"2024-07-25T15:08:06.000Z","updated":"2024-07-25T15:08:31.205Z","comments":true,"path":"2024/07/25/基于Centos7的UI自动化环境Dockerfile/","permalink":"https://linvaux.github.io/2024/07/25/%E5%9F%BA%E4%BA%8ECentos7%E7%9A%84UI%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83Dockerfile/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657FROM centos:7MAINTAINER linvaux &lt;linvaux@outlook.com&gt;WORKDIR /opt# 修改源，安装依赖RUN sed -i &quot;s/#baseurl/baseurl/g&quot; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\ sed -i &quot;s/mirrorlist=http/#mirrorlist=http/g&quot; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\ sed -i &quot;s@http://mirror.centos.org@https://repo.huaweicloud.com@g&quot; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\ yum clean all &amp;&amp; \\ yum makecache &amp;&amp; \\ yum update -y &amp;&amp; \\ yum install -y wget git zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc make# 安装JDK1.8RUN wget http://10.177.248.111:8089/ftp/dev_tools/jdk-8u271-linux-x64.tar.gz &amp;&amp; \\ tar -vxf jdk-8u271-linux-x64.tar.gz &amp;&amp; \\ mv jdk1.8.0_271/ /usr/local/ &amp;&amp; \\ echo &#x27;export JAVA_HOME=/usr/local/jdk1.8.0_271&#x27; &gt;&gt; /etc/profile &amp;&amp; \\ echo &#x27;export JRE_HOME=$&#123;JAVA_HOME&#125;/jre&#x27; &gt;&gt; /etc/profile &amp;&amp; \\ echo &#x27;export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib&#x27; &gt;&gt; /etc/profile &amp;&amp; \\ echo &#x27;export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH&#x27; &gt;&gt; /etc/profile echo `java -version`# 安装python3.7RUN wget https://mirrors.huaweicloud.com/python/3.7.8/Python-3.7.8.tgz &amp;&amp; \\ tar -vxf Python-3.7.8.tgz &amp;&amp; \\ mv Python-3.7.8 /usr/local/python378 &amp;&amp; \\ cd /usr/local/python378 &amp;&amp; \\ ./configure --prefix=/usr/local/python378 --enable-loadable-sqlite-extensions --with-ssl &amp;&amp;\\ make -j$(nproc) &amp;&amp; \\ make install -j$(nproc) &amp;&amp; \\ ln -s /usr/local/python378/bin/python3.7 /usr/bin/python3 &amp;&amp; \\ ln -s /usr/local/python378/bin/pip3 /usr/bin/pip3 &amp;&amp; \\ mkdir /root/.pip &amp;&amp; \\ echo &quot;[global]&quot; &gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;index-url=https://pypi.douban.com/simple/&quot; &gt;&gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;[install]&quot; &gt;&gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;trusted-host=pypi.douban.com&quot; &gt;&gt; /root/.pip/pip.conf echo `python3 -V`# 安装chromeRUN echo &#x27;[google-chrome]&#x27; &gt; /etc/yum.repos.d/google-chrome.repo &amp;&amp; \\ echo &#x27;name=google-chrome&#x27; &gt;&gt; /etc/yum.repos.d/google-chrome.repo &amp;&amp; \\ echo &#x27;baseurl=http://dl.google.com/linux/chrome/rpm/stable/$basearch&#x27; &gt;&gt; /etc/yum.repos.d/google-chrome.repo &amp;&amp; \\ echo &#x27;enabled=1&#x27; &gt;&gt; /etc/yum.repos.d/google-chrome.repo &amp;&amp; \\ echo &#x27;gpgcheck=1&#x27; &gt;&gt; /etc/yum.repos.d/google-chrome.repo &amp;&amp; \\ echo &#x27;gpgkey=https://dl-ssl.google.com/linux/linux_signing_key.pub&#x27; &gt;&gt; /etc/yum.repos.d/google-chrome.repo &amp;&amp; \\ yum -y install google-chrome-stable --nogpgcheck &amp;&amp; \\ echo `google-chrome --version`# 安装chromedriver驱动# 安装allureRUN rm -rf jdk-8u271-linux-x64.tar.gz &amp;&amp; \\ rm -rf Python-3.7.8.tgz &amp;&amp; \\ yum clean all","categories":[],"tags":[{"name":"Docker, 自动化测试","slug":"Docker-自动化测试","permalink":"https://linvaux.github.io/tags/Docker-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"}]},{"title":"基于Centos7的Python3.7镜像构建","slug":"基于Centos7的Python3-7镜像构建","date":"2024-07-25T15:07:16.000Z","updated":"2024-07-25T15:07:40.904Z","comments":true,"path":"2024/07/25/基于Centos7的Python3-7镜像构建/","permalink":"https://linvaux.github.io/2024/07/25/%E5%9F%BA%E4%BA%8ECentos7%E7%9A%84Python3-7%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA/","excerpt":"","text":"Dockerfile123456789101112131415161718192021222324252627282930FROM centos:7MAINTAINER linvaux &lt;linvaux@outlook.com&gt;WORKDIR /optRUN sed -i &quot;s/#baseurl/baseurl/g&quot; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\ sed -i &quot;s/mirrorlist=http/#mirrorlist=http/g&quot; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\ sed -i &quot;s@http://mirror.centos.org@https://repo.huaweicloud.com@g&quot; /etc/yum.repos.d/CentOS-Base.repo &amp;&amp; \\ yum clean all &amp;&amp; \\ yum makecache &amp;&amp; \\ yum update -yRUN yum install -y wget zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc makeRUN wget https://mirrors.huaweicloud.com/python/3.7.8/Python-3.7.8.tgz &amp;&amp; \\ tar -vxf Python-3.7.8.tgz &amp;&amp; \\ mv Python-3.7.8 /usr/local/python378 &amp;&amp; \\ cd /usr/local/python378 &amp;&amp; \\ ./configure --prefix=/usr/local/python378 --enable-loadable-sqlite-extensions --with-ssl &amp;&amp;\\ make -j$(nproc) &amp;&amp; \\ make install -j$(nproc) &amp;&amp; \\ ln -s /usr/local/python378/bin/python3.7 /usr/bin/python3 &amp;&amp; \\ ln -s /usr/local/python378/bin/pip3 /usr/bin/pip3 &amp;&amp; \\ mkdir /root/.pip &amp;&amp; \\ echo &quot;[global]&quot; &gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;index-url=https://pypi.douban.com/simple/&quot; &gt;&gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;[install]&quot; &gt;&gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;trusted-host=pypi.douban.com&quot; &gt;&gt; /root/.pip/pip.confRUN rm -rf Python-3.7.8.tgz 构建命令1docker build -t centos-python378 .","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://linvaux.github.io/tags/Docker/"}]},{"title":"基于Ubuntu16.04的Python3.7镜像构建","slug":"基于Ubuntu16-04的Python3-7镜像构建","date":"2024-07-25T15:06:21.000Z","updated":"2024-07-25T15:06:40.594Z","comments":true,"path":"2024/07/25/基于Ubuntu16-04的Python3-7镜像构建/","permalink":"https://linvaux.github.io/2024/07/25/%E5%9F%BA%E4%BA%8EUbuntu16-04%E7%9A%84Python3-7%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA/","excerpt":"","text":"Dockerfile12345678910111213141516171819202122232425262728FROM ubuntu:16.04MAINTAINER linvaux &lt;linvaux@outlook.com&gt;WORKDIR /optRUN sed -i &quot;s@http://.*archive.ubuntu.com@http://repo.huaweicloud.com@g&quot; /etc/apt/sources.list &amp;&amp; \\ sed -i &quot;s@http://.*security.ubuntu.com@http://repo.huaweicloud.com@g&quot; /etc/apt/sources.list &amp;&amp; \\ apt-get update &amp;&amp; \\ apt-get upgrade -yRUN apt-get install -y gcc make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev xz-utils tk-dev libffi-dev liblzma-devRUN wget https://mirrors.huaweicloud.com/python/3.7.8/Python-3.7.8.tgz &amp;&amp; \\ tar -vxf Python-3.7.8.tgz &amp;&amp; \\ mv Python-3.7.8 /usr/local/python378 &amp;&amp; \\ cd /usr/local/python378 &amp;&amp; \\ ./configure --prefix=/usr/local/python378 --enable-loadable-sqlite-extensions --with-ssl &amp;&amp;\\ make -j$(nproc) &amp;&amp; \\ make install -j$(nproc) &amp;&amp; \\ ln -s /usr/local/python378/bin/python3.7 /usr/bin/python3 &amp;&amp; \\ ln -s /usr/local/python378/bin/pip3 /usr/bin/pip3 &amp;&amp; \\ mkdir /root/.pip &amp;&amp; \\ echo &quot;[global]&quot; &gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;index-url=https://pypi.douban.com/simple/&quot; &gt;&gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;[install]&quot; &gt;&gt; /root/.pip/pip.conf &amp;&amp; \\ echo &quot;trusted-host=pypi.douban.com&quot; &gt;&gt; /root/.pip/pip.confRUN rm -rf Python-3.7.8.tgz 构建命令1docker build -t ubuntu-python378 .","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://linvaux.github.io/tags/Docker/"}]},{"title":"CentOS安装Google-Chrome浏览器","slug":"CentOS安装Google-Chrome浏览器","date":"2024-07-25T15:05:23.000Z","updated":"2024-07-25T15:06:01.769Z","comments":true,"path":"2024/07/25/CentOS安装Google-Chrome浏览器/","permalink":"https://linvaux.github.io/2024/07/25/CentOS%E5%AE%89%E8%A3%85Google-Chrome%E6%B5%8F%E8%A7%88%E5%99%A8/","excerpt":"","text":"配置yum源 在目录 &#x2F;etc&#x2F;yum.repos.d&#x2F; 下新建文件 google-chrome.repo 1vim /etc/yum.repos.d/google-chrome.repo 添加如下内容 123456[google-chrome]name=google-chromebaseurl=http://dl.google.com/linux/chrome/rpm/stable/$basearchenabled=1gpgcheck=1gpgkey=https://dl-ssl.google.com/linux/linux_signing_key.pub 安装google chrome浏览器及chromedriver Google官方源安装： 12yum makecacheyum -y install google-chrome-stable Google官方源可能在中国无法使用，导致安装失败或者在国内无法更新，可以添加以下参数来安装： 1yum -y install google-chrome-stable --nogpgcheck 检查chrome版本 1google-chrome --version 下载对应版本的的chromedriver 检查chromedriver版本 1chromedriver --version","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://linvaux.github.io/tags/Docker/"}]},{"title":"Mac使用Jenv实现Jdk多版本管理","slug":"Mac使用Jenv实现Jdk多版本管理","date":"2024-07-25T14:53:58.000Z","updated":"2024-07-25T15:00:39.446Z","comments":true,"path":"2024/07/25/Mac使用Jenv实现Jdk多版本管理/","permalink":"https://linvaux.github.io/2024/07/25/Mac%E4%BD%BF%E7%94%A8Jenv%E5%AE%9E%E7%8E%B0Jdk%E5%A4%9A%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/","excerpt":"","text":"前言目前在开发过程中，需要同时安装 Jdk8, Jdk11, Jdk17 进行项目开发，为了统一管理Jdk 环境，需要一款类似 conda 的工具来管理多套 Jdk 环境，可选的方案有以下几种： 使用 shell 脚本来动态设置 JAVA_HOME； 使用 scoop 来管理环境； 使用 jenv 来管理环境； 经过使用体验，最后选择了 jenv 来做 jdk 版本管理。 安装在 mac 下面可以使用 brew 来安装 jenv 1brew install jenv 我用的 zsh，因此还需要将 jenv 添加到 zsh 中 123echo &#x27;export PATH=&quot;$HOME/.jenv/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc# 执行 jenv 初始化脚本，类似于 conda init 命令echo &#x27;eval &quot;$(jenv init -)&quot;&#x27; &gt;&gt; ~/.zshrc 配置1.添加在本地已经安装的 jdk123jenv add /Library/Java/JavaVirtualMachines/jdk-17.0.5.jdk/Contents/Home/jenv add /Library/Java/JavaVirtualMachines/jdk1.8.0_301.jdk/Contents/Home/jenv add /Library/Java/JavaVirtualMachines/jdk-11.0.11.jdk/Contents/Home/ 2.列出已经添加的 jdk 版本1jenv versions 3.设置 jdk 的三种方式 jenv local ：该命令将会在当前目录下设置特定的 Java 版本。这意味着只有在该目录下执行程序调用时才会使用该版本的 Java。 jenv global ：该命令将会设置系统全局的 Java 版本。当在终端或其它地方运行 Java 应用程序时，都将使用该版本的 Java。 jenv shell ：该命令将会在当前 Shell 会话中设置特定的 Java 版本。这意味着只有在该 Shell 会话中执行程序调用时才会使用该版本的 Java。 因此，这三个命令的主要区别在于设置 Java 版本的作用域和范围。jenv local 的作用域仅限于当前工作目录，jenv global 的作用域与操作系统全局环境相关，而 jenv shell 的作用域仅限于当前 Shell 会话。因此，根据具体情况选择使用不同的命令。需要注意的是，jenv 只对使用 jenv exec 执行的命令生效，对于直接使用 java 命令执行的程序，jenv 并不会自动切换 Java 版本。因此，需要手动设置系统环境变量或使用别的工具来切换 Java 版本。 4.Jenv 诊断jenv doctor 是 jenv 命令行工具提供的一个诊断工具，用于检查本地系统的 Java 环境是否正确配置。当我们安装 jenv 后，需要将其配置到系统环境变量中，并安装所需的 Java 版本。使用 jenv doctor 命令可以检测配置和 Java 版本是否正确安装，并提供诊断信息和建议以解决检测出的问题。jenv doctor 常见的使用场景有： 检查 jenv 的环境变量是否正确配置。jenv 是一款基于环境变量来管理多个 Java 版本的工具，因此我们需要将其配置到系统环境变量中，并确保环境变量的正确性。 检查 jenv 的安装路径和版本号。检查 jenv 实际安装的位置以及当前所用的版本号，是否符合预期要求。 检查可用的 Java 版本是否正确安装和配置。jenv doctor 会检查本地系统环境中已经安装的 Java 版本，是否安装在了 jenv 管理的目录中，并支持在 jenv 中进行切换。 参考文档 Jenv 官方文档","categories":[{"name":"工具分享","slug":"工具分享","permalink":"https://linvaux.github.io/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Mac, JDK","slug":"Mac-JDK","permalink":"https://linvaux.github.io/tags/Mac-JDK/"}]},{"title":"Pytest参数","slug":"Pytest参数","date":"2024-07-25T14:40:14.000Z","updated":"2024-07-25T14:40:51.371Z","comments":true,"path":"2024/07/25/Pytest参数/","permalink":"https://linvaux.github.io/2024/07/25/Pytest%E5%8F%82%E6%95%B0/","excerpt":"","text":"分类 参数 作用 general -k 支持python的表达式，用于筛选指定标记&#x2F;方法名的用例 -m 根据用例标签来筛选用例，设置标签可以使用 @pytest.mark.&lt;标签名&gt; –markers 打印标签，包括内置的，插件的，还有自定义的 -x 第一个error或failed的test就退出 –fixtures 显示可用的fixture，包括内置和自己写的，如果fixture使用 “_”开头则需要使用-v才能显示此fixture –fixtures-per-test 展示每条用例的fixture –pdb 当用例出现错误或者被键盘中断后，启动pdb调试 –pdbcls&#x3D;modulename:classname 启动自定义pdb debugger，一般用不到这个 –trace 执行测试用例时break，进入debugger –capture&#x3D;method 标准输出&#x2F;标准错误输出&#x2F;标准输入的默认捕获，fd：标准输入，标准错误输出都会捕获；sys：只有向Python的sys.stdout和sys.stderr的写入行为会被捕获，不执行对文件描述符的写入的捕获；no：对print语句内容捕获，等同于 -s -s 显示print语句的内容 –runxfail 强制运行xfail标记的用例 –lf, –last-failed 重新执行上次测试执行失败的用例，如果没有失败的用例，则执行全部用例 –ff, –failed-first 优先跑上次失败的test，tests的顺序会被打乱 –nf, –new-first 优先跑新添加的tests，剩余的按文件mtime顺序 –cache-show&#x3D;[CACHESHOW] 显示缓存，默认 * 显示所有缓存，可以带参数 pytest –cache-show&#x3D;cache&#x2F;nodeids –cache-clear 在执行用例前，清理pytest缓存 –lfnf&#x3D;{all,none}, –last-failed-no-failures&#x3D;{all,none} 没有last-failed缓存数据，或上次没有失败时，执行全部用例 –sw, –stepwise 逐步运行，在失败时退出，下次运行时从失败的用例开始 –stepwise-skip 跳过第一个失败的test，如果再遇到失败就退出 reporting –durations&#x3D;N 显示N个最慢的setup&#x2F;test的耗时，N&#x3D;0时，显示所有耗时 –durations-min&#x3D;N 显示N个最小的setup&#x2F;test的耗时 -v, –verbose 输出详细信息 –no-header 不显示pytest消息头，只展示用例信息 –no-summary 不显示用例执行完的summary info -q, –quiet 静默模式，不输出任何内容 –verbosity&#x3D;VERBOSE 信息显示等级，貌似没啥用 -r chars -r f：显示failed信息；-r E：显示error信息；-r s：显示skipped信息；-r x：显示xfailed信息；-r X：显示xpassed信息；-r p：显示passed信息；-r P：显示 passed with output信息； -r a&#x2F;A：显示 all except passed信息；-r w：显示默认告警信息；-r N：重置list –disable-warnings, –disable-pytest-warnings 禁用pytest告警，如未注册的标记等 -l, –showlocal 用例执行失败时，打印堆栈信息，默认被禁用 –tb&#x3D;style traceback打印模式，一般设置为auto即可 –show-capture&#x3D;{no,stdout,stderr,log,all} 失败的用例如何显示，默认为all –full-trace 不截取traceback，默认会截断 –color&#x3D;color 是否显示彩色，yes：显示颜色；no：不显示颜色；auto：自动 –code-highlight&#x3D;{yes,no} 代码是否高亮显示，一般用不到 –pastebin&#x3D;mode 没什么用的参数，我也不知道干嘛的 –junit-xml&#x3D;path 在给定的path路径下生成junit-xml风格的测试报告 –junit-prefix&#x3D;str 在junit-xml输出中的classnames添加前缀 pytest-warnings -W PYTHONWARNINGS, –pythonwarnings&#x3D;PYTHONWARNINGS 设置报告哪些warnings –maxfail&#x3D;num 出现num个errors或者fails就退出测试 –strict-config 解析配置文件中pytest部分时，遇到warning就抛出error –strict-markers, –strict 发现未知标记时，抛出error， -c file 从指定配置文件加载配置，默认为pytes.ini –continue-on-collection-errors 在收集用例时发生错误，也会继续执行用例 –rootdir&#x3D;ROOTDIR tests根目录，相对路径 collection –collect-only, –co 收集用例，但不执行 –pyargs 把所有参数解释为python包 –ignore&#x3D;path 忽略测试目录，使用英文逗号分割 –ignore-glob&#x3D;path path匹配多个不需要收集的测试目录，使用英文逗号分割 –deselect&#x3D;nodeid_prefix 通过node id prefix反选。可以多个，使用英文逗号分隔 –confcutdir&#x3D;dir 只加载相对于dir目录的conftest.py文件 –noconftest 不加载conftest.py文件 –keep-duplicates 收集重复的test文件，默认只会收集1item，加参数后会收集2items –collect-in-virtualenv 收集本地虚拟环境目录的tests –import-mode&#x3D;{prepend,append,importlib} 包导入模式，一般用不到，参考：https://www.osgeo.cn/pytest/pythonpath.html?highlight=import%20mode –doctest-modules 文档测试，没啥用 –doctest-report&#x3D;{none,cdiff,ndiff,udiff,only_first_failure} 一样，也没啥用 –doctest-glob&#x3D;pat 还是没啥用 –doctest-ignore-import-errors 文档测试时忽略导包错误，继续没什么用 –doctest-continue-on-failure 文档测试时出现失败继续测试，依然没什么用 test session debugging and configuration –basetemp&#x3D;dir test run的base临时目录（如果存在会先删除） -V, –version 输出pytest版本 -h, –help 打印pytest帮助信息 -p name 加载插件，一般不会控制此参数 –trace-config 查看本地安装好的第三方插件 –debug 保存debug信息到’pytestdebug.log’文件 -o OVERRIDE_INI, –override-ini&#x3D;OVERRIDE_INI 覆盖ini文件配置 –assert&#x3D;MODE 断言模式，默认rewrite –setup-only 只加载fixture，不执行测试用例 –setup-show 在执行测试用例时，打印fixture步骤 –setup-plan 展示哪些用例和fixture将要被执行 logging –log-level&#x3D;LEVEL 日志等级，默认 WARNING （具体日志等级参考 logging 模块中的日志等级） –log-format&#x3D;LOG_FORMAT 日志格式（具体日志格式参考 logging 模块中的日志格式） –log-date-format&#x3D;LOG_DATE_FORMA 日志日期格式（具体日志格式参考 logging 模块中的日志格式） –log-cli-level&#x3D;LOG_CLI_LEVEL cli日志等级（具体日志等级参考 logging 模块中的日志等级） –log-cli-format&#x3D;LOG_CLI_FORMAT cli日志格式（具体日志格式参考 logging 模块中的日志格式） –log-cli-date-format&#x3D;LOG_CLI_DATE_FORMAT cli日志日期格式（具体日志格式参考 logging 模块中的日志格式） –log-file&#x3D;LOG_FILE 日志文件路径 –log-file-level&#x3D;LOG_FILE_LEVE 日志文件中的日志等级 –log-file-format&#x3D;LOG_FILE_FORMAT 日志文件中的日志格式 –log-file-date-format&#x3D;LOG_FILE_DATE_FORMAT 日志文件中的日志时间格式 –log-auto-indent&#x3D;LOG_AUTO_INDENT 自动缩进传递给日志模块的多行消息。接受true | on、false | off或整数","categories":[{"name":"测试","slug":"测试","permalink":"https://linvaux.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"Pytest","slug":"Pytest","permalink":"https://linvaux.github.io/tags/Pytest/"}]}],"categories":[{"name":"工具分享","slug":"工具分享","permalink":"https://linvaux.github.io/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"},{"name":"测试","slug":"测试","permalink":"https://linvaux.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linvaux.github.io/tags/Java/"},{"name":"Jmeter源码系列","slug":"Jmeter源码系列","permalink":"https://linvaux.github.io/tags/Jmeter%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"},{"name":"IDEA","slug":"IDEA","permalink":"https://linvaux.github.io/tags/IDEA/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://linvaux.github.io/tags/Jenkins/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://linvaux.github.io/tags/SpringBoot/"},{"name":"LogStash","slug":"LogStash","permalink":"https://linvaux.github.io/tags/LogStash/"},{"name":"Java, EasyExcel","slug":"Java-EasyExcel","permalink":"https://linvaux.github.io/tags/Java-EasyExcel/"},{"name":"Java, IDEA","slug":"Java-IDEA","permalink":"https://linvaux.github.io/tags/Java-IDEA/"},{"name":"Docker, 自动化测试","slug":"Docker-自动化测试","permalink":"https://linvaux.github.io/tags/Docker-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"Docker","slug":"Docker","permalink":"https://linvaux.github.io/tags/Docker/"},{"name":"Mac, JDK","slug":"Mac-JDK","permalink":"https://linvaux.github.io/tags/Mac-JDK/"},{"name":"Pytest","slug":"Pytest","permalink":"https://linvaux.github.io/tags/Pytest/"}]}