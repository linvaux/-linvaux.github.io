{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://linvaux.github.io","root":"/"},"pages":[{"title":"categories","date":"2024-07-25T14:43:59.000Z","updated":"2024-07-25T14:43:59.465Z","comments":true,"path":"categories/index.html","permalink":"https://linvaux.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2024-07-25T14:43:48.000Z","updated":"2024-07-25T14:43:48.484Z","comments":true,"path":"tags/index.html","permalink":"https://linvaux.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Mac使用Jenv实现Jdk多版本管理","slug":"Mac使用Jenv实现Jdk多版本管理","date":"2024-07-25T14:53:58.000Z","updated":"2024-07-25T15:00:39.446Z","comments":true,"path":"2024/07/25/Mac使用Jenv实现Jdk多版本管理/","permalink":"https://linvaux.github.io/2024/07/25/Mac%E4%BD%BF%E7%94%A8Jenv%E5%AE%9E%E7%8E%B0Jdk%E5%A4%9A%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/","excerpt":"","text":"前言目前在开发过程中，需要同时安装 Jdk8, Jdk11, Jdk17 进行项目开发，为了统一管理Jdk 环境，需要一款类似 conda 的工具来管理多套 Jdk 环境，可选的方案有以下几种： 使用 shell 脚本来动态设置 JAVA_HOME； 使用 scoop 来管理环境； 使用 jenv 来管理环境； 经过使用体验，最后选择了 jenv 来做 jdk 版本管理。 安装在 mac 下面可以使用 brew 来安装 jenv 1brew install jenv 我用的 zsh，因此还需要将 jenv 添加到 zsh 中 123echo &#x27;export PATH=&quot;$HOME/.jenv/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc# 执行 jenv 初始化脚本，类似于 conda init 命令echo &#x27;eval &quot;$(jenv init -)&quot;&#x27; &gt;&gt; ~/.zshrc 配置1.添加在本地已经安装的 jdk123jenv add /Library/Java/JavaVirtualMachines/jdk-17.0.5.jdk/Contents/Home/jenv add /Library/Java/JavaVirtualMachines/jdk1.8.0_301.jdk/Contents/Home/jenv add /Library/Java/JavaVirtualMachines/jdk-11.0.11.jdk/Contents/Home/ 2.列出已经添加的 jdk 版本1jenv versions 3.设置 jdk 的三种方式 jenv local ：该命令将会在当前目录下设置特定的 Java 版本。这意味着只有在该目录下执行程序调用时才会使用该版本的 Java。 jenv global ：该命令将会设置系统全局的 Java 版本。当在终端或其它地方运行 Java 应用程序时，都将使用该版本的 Java。 jenv shell ：该命令将会在当前 Shell 会话中设置特定的 Java 版本。这意味着只有在该 Shell 会话中执行程序调用时才会使用该版本的 Java。 因此，这三个命令的主要区别在于设置 Java 版本的作用域和范围。jenv local 的作用域仅限于当前工作目录，jenv global 的作用域与操作系统全局环境相关，而 jenv shell 的作用域仅限于当前 Shell 会话。因此，根据具体情况选择使用不同的命令。需要注意的是，jenv 只对使用 jenv exec 执行的命令生效，对于直接使用 java 命令执行的程序，jenv 并不会自动切换 Java 版本。因此，需要手动设置系统环境变量或使用别的工具来切换 Java 版本。 4.Jenv 诊断jenv doctor 是 jenv 命令行工具提供的一个诊断工具，用于检查本地系统的 Java 环境是否正确配置。当我们安装 jenv 后，需要将其配置到系统环境变量中，并安装所需的 Java 版本。使用 jenv doctor 命令可以检测配置和 Java 版本是否正确安装，并提供诊断信息和建议以解决检测出的问题。jenv doctor 常见的使用场景有： 检查 jenv 的环境变量是否正确配置。jenv 是一款基于环境变量来管理多个 Java 版本的工具，因此我们需要将其配置到系统环境变量中，并确保环境变量的正确性。 检查 jenv 的安装路径和版本号。检查 jenv 实际安装的位置以及当前所用的版本号，是否符合预期要求。 检查可用的 Java 版本是否正确安装和配置。jenv doctor 会检查本地系统环境中已经安装的 Java 版本，是否安装在了 jenv 管理的目录中，并支持在 jenv 中进行切换。 参考文档 Jenv 官方文档","categories":[{"name":"工具分享","slug":"工具分享","permalink":"https://linvaux.github.io/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Mac, JDK","slug":"Mac-JDK","permalink":"https://linvaux.github.io/tags/Mac-JDK/"}]},{"title":"Pytest参数","slug":"Pytest参数","date":"2024-07-25T14:40:14.000Z","updated":"2024-07-25T14:40:51.371Z","comments":true,"path":"2024/07/25/Pytest参数/","permalink":"https://linvaux.github.io/2024/07/25/Pytest%E5%8F%82%E6%95%B0/","excerpt":"","text":"分类 参数 作用 general -k 支持python的表达式，用于筛选指定标记&#x2F;方法名的用例 -m 根据用例标签来筛选用例，设置标签可以使用 @pytest.mark.&lt;标签名&gt; –markers 打印标签，包括内置的，插件的，还有自定义的 -x 第一个error或failed的test就退出 –fixtures 显示可用的fixture，包括内置和自己写的，如果fixture使用 “_”开头则需要使用-v才能显示此fixture –fixtures-per-test 展示每条用例的fixture –pdb 当用例出现错误或者被键盘中断后，启动pdb调试 –pdbcls&#x3D;modulename:classname 启动自定义pdb debugger，一般用不到这个 –trace 执行测试用例时break，进入debugger –capture&#x3D;method 标准输出&#x2F;标准错误输出&#x2F;标准输入的默认捕获，fd：标准输入，标准错误输出都会捕获；sys：只有向Python的sys.stdout和sys.stderr的写入行为会被捕获，不执行对文件描述符的写入的捕获；no：对print语句内容捕获，等同于 -s -s 显示print语句的内容 –runxfail 强制运行xfail标记的用例 –lf, –last-failed 重新执行上次测试执行失败的用例，如果没有失败的用例，则执行全部用例 –ff, –failed-first 优先跑上次失败的test，tests的顺序会被打乱 –nf, –new-first 优先跑新添加的tests，剩余的按文件mtime顺序 –cache-show&#x3D;[CACHESHOW] 显示缓存，默认 * 显示所有缓存，可以带参数 pytest –cache-show&#x3D;cache&#x2F;nodeids –cache-clear 在执行用例前，清理pytest缓存 –lfnf&#x3D;{all,none}, –last-failed-no-failures&#x3D;{all,none} 没有last-failed缓存数据，或上次没有失败时，执行全部用例 –sw, –stepwise 逐步运行，在失败时退出，下次运行时从失败的用例开始 –stepwise-skip 跳过第一个失败的test，如果再遇到失败就退出 reporting –durations&#x3D;N 显示N个最慢的setup&#x2F;test的耗时，N&#x3D;0时，显示所有耗时 –durations-min&#x3D;N 显示N个最小的setup&#x2F;test的耗时 -v, –verbose 输出详细信息 –no-header 不显示pytest消息头，只展示用例信息 –no-summary 不显示用例执行完的summary info -q, –quiet 静默模式，不输出任何内容 –verbosity&#x3D;VERBOSE 信息显示等级，貌似没啥用 -r chars -r f：显示failed信息；-r E：显示error信息；-r s：显示skipped信息；-r x：显示xfailed信息；-r X：显示xpassed信息；-r p：显示passed信息；-r P：显示 passed with output信息； -r a&#x2F;A：显示 all except passed信息；-r w：显示默认告警信息；-r N：重置list –disable-warnings, –disable-pytest-warnings 禁用pytest告警，如未注册的标记等 -l, –showlocal 用例执行失败时，打印堆栈信息，默认被禁用 –tb&#x3D;style traceback打印模式，一般设置为auto即可 –show-capture&#x3D;{no,stdout,stderr,log,all} 失败的用例如何显示，默认为all –full-trace 不截取traceback，默认会截断 –color&#x3D;color 是否显示彩色，yes：显示颜色；no：不显示颜色；auto：自动 –code-highlight&#x3D;{yes,no} 代码是否高亮显示，一般用不到 –pastebin&#x3D;mode 没什么用的参数，我也不知道干嘛的 –junit-xml&#x3D;path 在给定的path路径下生成junit-xml风格的测试报告 –junit-prefix&#x3D;str 在junit-xml输出中的classnames添加前缀 pytest-warnings -W PYTHONWARNINGS, –pythonwarnings&#x3D;PYTHONWARNINGS 设置报告哪些warnings –maxfail&#x3D;num 出现num个errors或者fails就退出测试 –strict-config 解析配置文件中pytest部分时，遇到warning就抛出error –strict-markers, –strict 发现未知标记时，抛出error， -c file 从指定配置文件加载配置，默认为pytes.ini –continue-on-collection-errors 在收集用例时发生错误，也会继续执行用例 –rootdir&#x3D;ROOTDIR tests根目录，相对路径 collection –collect-only, –co 收集用例，但不执行 –pyargs 把所有参数解释为python包 –ignore&#x3D;path 忽略测试目录，使用英文逗号分割 –ignore-glob&#x3D;path path匹配多个不需要收集的测试目录，使用英文逗号分割 –deselect&#x3D;nodeid_prefix 通过node id prefix反选。可以多个，使用英文逗号分隔 –confcutdir&#x3D;dir 只加载相对于dir目录的conftest.py文件 –noconftest 不加载conftest.py文件 –keep-duplicates 收集重复的test文件，默认只会收集1item，加参数后会收集2items –collect-in-virtualenv 收集本地虚拟环境目录的tests –import-mode&#x3D;{prepend,append,importlib} 包导入模式，一般用不到，参考：https://www.osgeo.cn/pytest/pythonpath.html?highlight=import%20mode –doctest-modules 文档测试，没啥用 –doctest-report&#x3D;{none,cdiff,ndiff,udiff,only_first_failure} 一样，也没啥用 –doctest-glob&#x3D;pat 还是没啥用 –doctest-ignore-import-errors 文档测试时忽略导包错误，继续没什么用 –doctest-continue-on-failure 文档测试时出现失败继续测试，依然没什么用 test session debugging and configuration –basetemp&#x3D;dir test run的base临时目录（如果存在会先删除） -V, –version 输出pytest版本 -h, –help 打印pytest帮助信息 -p name 加载插件，一般不会控制此参数 –trace-config 查看本地安装好的第三方插件 –debug 保存debug信息到’pytestdebug.log’文件 -o OVERRIDE_INI, –override-ini&#x3D;OVERRIDE_INI 覆盖ini文件配置 –assert&#x3D;MODE 断言模式，默认rewrite –setup-only 只加载fixture，不执行测试用例 –setup-show 在执行测试用例时，打印fixture步骤 –setup-plan 展示哪些用例和fixture将要被执行 logging –log-level&#x3D;LEVEL 日志等级，默认 WARNING （具体日志等级参考 logging 模块中的日志等级） –log-format&#x3D;LOG_FORMAT 日志格式（具体日志格式参考 logging 模块中的日志格式） –log-date-format&#x3D;LOG_DATE_FORMA 日志日期格式（具体日志格式参考 logging 模块中的日志格式） –log-cli-level&#x3D;LOG_CLI_LEVEL cli日志等级（具体日志等级参考 logging 模块中的日志等级） –log-cli-format&#x3D;LOG_CLI_FORMAT cli日志格式（具体日志格式参考 logging 模块中的日志格式） –log-cli-date-format&#x3D;LOG_CLI_DATE_FORMAT cli日志日期格式（具体日志格式参考 logging 模块中的日志格式） –log-file&#x3D;LOG_FILE 日志文件路径 –log-file-level&#x3D;LOG_FILE_LEVE 日志文件中的日志等级 –log-file-format&#x3D;LOG_FILE_FORMAT 日志文件中的日志格式 –log-file-date-format&#x3D;LOG_FILE_DATE_FORMAT 日志文件中的日志时间格式 –log-auto-indent&#x3D;LOG_AUTO_INDENT 自动缩进传递给日志模块的多行消息。接受true | on、false | off或整数","categories":[{"name":"测试","slug":"测试","permalink":"https://linvaux.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"Pytest","slug":"Pytest","permalink":"https://linvaux.github.io/tags/Pytest/"}]}],"categories":[{"name":"工具分享","slug":"工具分享","permalink":"https://linvaux.github.io/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"},{"name":"测试","slug":"测试","permalink":"https://linvaux.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"Mac, JDK","slug":"Mac-JDK","permalink":"https://linvaux.github.io/tags/Mac-JDK/"},{"name":"Pytest","slug":"Pytest","permalink":"https://linvaux.github.io/tags/Pytest/"}]}