<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://linvaux.github.io/atom.xml" rel="self"/>
  
  <link href="https://linvaux.github.io/"/>
  <updated>2024-07-25T15:00:39.446Z</updated>
  <id>https://linvaux.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac使用Jenv实现Jdk多版本管理</title>
    <link href="https://linvaux.github.io/2024/07/25/Mac%E4%BD%BF%E7%94%A8Jenv%E5%AE%9E%E7%8E%B0Jdk%E5%A4%9A%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    <id>https://linvaux.github.io/2024/07/25/Mac%E4%BD%BF%E7%94%A8Jenv%E5%AE%9E%E7%8E%B0Jdk%E5%A4%9A%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</id>
    <published>2024-07-25T14:53:58.000Z</published>
    <updated>2024-07-25T15:00:39.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前在开发过程中，需要同时安装 Jdk8, Jdk11, Jdk17 进行项目开发，为了统一管理Jdk 环境，需要一款类似 conda 的工具来管理多套 Jdk 环境，可选的方案有以下几种：</p><ol><li>使用 shell 脚本来动态设置 JAVA_HOME；</li><li>使用 scoop 来管理环境；</li><li>使用 jenv 来管理环境；</li></ol><p>经过使用体验，最后选择了 jenv 来做 jdk 版本管理。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在 mac 下面可以使用 brew 来安装 jenv</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install jenv</span><br></pre></td></tr></table></figure><p>我用的 zsh，因此还需要将 jenv 添加到 zsh 中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;export PATH=&quot;$HOME/.jenv/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行 jenv 初始化脚本，类似于 conda init 命令</span></span><br><span class="line">echo &#x27;eval &quot;$(jenv init -)&quot;&#x27; &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="1-添加在本地已经安装的-jdk"><a href="#1-添加在本地已经安装的-jdk" class="headerlink" title="1.添加在本地已经安装的 jdk"></a>1.添加在本地已经安装的 jdk</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jenv add /Library/Java/JavaVirtualMachines/jdk-17.0.5.jdk/Contents/Home/</span><br><span class="line">jenv add /Library/Java/JavaVirtualMachines/jdk1.8.0_301.jdk/Contents/Home/</span><br><span class="line">jenv add /Library/Java/JavaVirtualMachines/jdk-11.0.11.jdk/Contents/Home/</span><br></pre></td></tr></table></figure><h3 id="2-列出已经添加的-jdk-版本"><a href="#2-列出已经添加的-jdk-版本" class="headerlink" title="2.列出已经添加的 jdk 版本"></a>2.列出已经添加的 jdk 版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jenv versions</span><br></pre></td></tr></table></figure><p><img src="/../images/iSQTdua4zwUJpzHvEXp7yxnr.png" alt="image.png"></p><h3 id="3-设置-jdk-的三种方式"><a href="#3-设置-jdk-的三种方式" class="headerlink" title="3.设置 jdk 的三种方式"></a>3.设置 jdk 的三种方式</h3><ol><li><p>jenv local <version>：该命令将会在当前目录下设置特定的 Java 版本。这意味着只有在该目录下执行程序调用时才会使用该版本的 Java。</p></li><li><p>jenv global <version>：该命令将会设置系统全局的 Java 版本。当在终端或其它地方运行 Java 应用程序时，都将使用该版本的 Java。</p></li><li><p>jenv shell <version>：该命令将会在当前 Shell 会话中设置特定的 Java 版本。这意味着只有在该 Shell 会话中执行程序调用时才会使用该版本的 Java。</p><p> 因此，这三个命令的主要区别在于设置 Java 版本的作用域和范围。jenv local 的作用域仅限于当前工作目录，jenv global 的作用域与操作系统全局环境相关，而 jenv shell 的作用域仅限于当前 Shell 会话。因此，根据具体情况选择使用不同的命令。需要注意的是，jenv 只对使用 jenv exec 执行的命令生效，对于直接使用 java 命令执行的程序，jenv 并不会自动切换 Java 版本。因此，需要手动设置系统环境变量或使用别的工具来切换 Java 版本。</p></li></ol><h3 id="4-Jenv-诊断"><a href="#4-Jenv-诊断" class="headerlink" title="4.Jenv 诊断"></a>4.Jenv 诊断</h3><p>jenv doctor 是 jenv 命令行工具提供的一个诊断工具，用于检查本地系统的 Java 环境是否正确配置。当我们安装 jenv 后，需要将其配置到系统环境变量中，并安装所需的 Java 版本。使用 jenv doctor 命令可以检测配置和 Java 版本是否正确安装，并提供诊断信息和建议以解决检测出的问题。jenv doctor 常见的使用场景有：</p><ol><li>检查 jenv 的环境变量是否正确配置。jenv 是一款基于环境变量来管理多个 Java 版本的工具，因此我们需要将其配置到系统环境变量中，并确保环境变量的正确性。</li><li>检查 jenv 的安装路径和版本号。检查 jenv 实际安装的位置以及当前所用的版本号，是否符合预期要求。</li><li>检查可用的 Java 版本是否正确安装和配置。jenv doctor 会检查本地系统环境中已经安装的 Java 版本，是否安装在了 jenv 管理的目录中，并支持在 jenv 中进行切换。</li></ol><p><img src="/../images/VuWUGUBYvMFibu1RHPRre6Qn.png" alt="image.png"></p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol><li><a href="https://www.jenv.be/">Jenv 官方文档</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;目前在开发过程中，需要同时安装 Jdk8, Jdk11, Jdk17 进行项目开发，为了统一管理Jdk 环境，需要一款类似 conda 的工</summary>
      
    
    
    
    <category term="工具分享" scheme="https://linvaux.github.io/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="Mac, JDK" scheme="https://linvaux.github.io/tags/Mac-JDK/"/>
    
  </entry>
  
  <entry>
    <title>Pytest参数</title>
    <link href="https://linvaux.github.io/2024/07/25/Pytest%E5%8F%82%E6%95%B0/"/>
    <id>https://linvaux.github.io/2024/07/25/Pytest%E5%8F%82%E6%95%B0/</id>
    <published>2024-07-25T14:40:14.000Z</published>
    <updated>2024-07-25T14:40:51.371Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>分类</th><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>general</td><td>-k</td><td>支持python的表达式，用于筛选指定标记&#x2F;方法名的用例</td></tr><tr><td>-m</td><td>根据用例标签来筛选用例，设置标签可以使用  @pytest.mark.&lt;标签名&gt;</td><td></td></tr><tr><td>–markers</td><td>打印标签，包括内置的，插件的，还有自定义的</td><td></td></tr><tr><td>-x</td><td>第一个error或failed的test就退出</td><td></td></tr><tr><td>–fixtures</td><td>显示可用的fixture，包括内置和自己写的，如果fixture使用  “_”开头则需要使用-v才能显示此fixture</td><td></td></tr><tr><td>–fixtures-per-test</td><td>展示每条用例的fixture</td><td></td></tr><tr><td>–pdb</td><td>当用例出现错误或者被键盘中断后，启动pdb调试</td><td></td></tr><tr><td>–pdbcls&#x3D;modulename:classname</td><td>启动自定义pdb  debugger，一般用不到这个</td><td></td></tr><tr><td>–trace</td><td>执行测试用例时break，进入debugger</td><td></td></tr><tr><td>–capture&#x3D;method</td><td>标准输出&#x2F;标准错误输出&#x2F;标准输入的默认捕获，fd：标准输入，标准错误输出都会捕获；sys：只有向Python的sys.stdout和sys.stderr的写入行为会被捕获，不执行对文件描述符的写入的捕获；no：对print语句内容捕获，等同于  -s</td><td></td></tr><tr><td>-s</td><td>显示print语句的内容</td><td></td></tr><tr><td>–runxfail</td><td>强制运行xfail标记的用例</td><td></td></tr><tr><td>–lf, –last-failed</td><td>重新执行上次测试执行失败的用例，如果没有失败的用例，则执行全部用例</td><td></td></tr><tr><td>–ff, –failed-first</td><td>优先跑上次失败的test，tests的顺序会被打乱</td><td></td></tr><tr><td>–nf, –new-first</td><td>优先跑新添加的tests，剩余的按文件mtime顺序</td><td></td></tr><tr><td>–cache-show&#x3D;[CACHESHOW]</td><td>显示缓存，默认  * 显示所有缓存，可以带参数 pytest –cache-show&#x3D;cache&#x2F;nodeids</td><td></td></tr><tr><td>–cache-clear</td><td>在执行用例前，清理pytest缓存</td><td></td></tr><tr><td>–lfnf&#x3D;{all,none},  –last-failed-no-failures&#x3D;{all,none}</td><td>没有last-failed缓存数据，或上次没有失败时，执行全部用例</td><td></td></tr><tr><td>–sw, –stepwise</td><td>逐步运行，在失败时退出，下次运行时从失败的用例开始</td><td></td></tr><tr><td>–stepwise-skip</td><td>跳过第一个失败的test，如果再遇到失败就退出</td><td></td></tr><tr><td>reporting</td><td>–durations&#x3D;N</td><td>显示N个最慢的setup&#x2F;test的耗时，N&#x3D;0时，显示所有耗时</td></tr><tr><td>–durations-min&#x3D;N</td><td>显示N个最小的setup&#x2F;test的耗时</td><td></td></tr><tr><td>-v, –verbose</td><td>输出详细信息</td><td></td></tr><tr><td>–no-header</td><td>不显示pytest消息头，只展示用例信息</td><td></td></tr><tr><td>–no-summary</td><td>不显示用例执行完的summary  info</td><td></td></tr><tr><td>-q, –quiet</td><td>静默模式，不输出任何内容</td><td></td></tr><tr><td>–verbosity&#x3D;VERBOSE</td><td>信息显示等级，貌似没啥用</td><td></td></tr><tr><td>-r chars</td><td>-r  f：显示failed信息；-r E：显示error信息；-r s：显示skipped信息；-r x：显示xfailed信息；-r  X：显示xpassed信息；-r p：显示passed信息；-r P：显示   passed with output信息； -r a&#x2F;A：显示 all except passed信息；-r w：显示默认告警信息；-r  N：重置list</td><td></td></tr><tr><td>–disable-warnings, –disable-pytest-warnings</td><td>禁用pytest告警，如未注册的标记等</td><td></td></tr><tr><td>-l, –showlocal</td><td>用例执行失败时，打印堆栈信息，默认被禁用</td><td></td></tr><tr><td>–tb&#x3D;style</td><td>traceback打印模式，一般设置为auto即可</td><td></td></tr><tr><td>–show-capture&#x3D;{no,stdout,stderr,log,all}</td><td>失败的用例如何显示，默认为all</td><td></td></tr><tr><td>–full-trace</td><td>不截取traceback，默认会截断</td><td></td></tr><tr><td>–color&#x3D;color</td><td>是否显示彩色，yes：显示颜色；no：不显示颜色；auto：自动</td><td></td></tr><tr><td>–code-highlight&#x3D;{yes,no}</td><td>代码是否高亮显示，一般用不到</td><td></td></tr><tr><td>–pastebin&#x3D;mode</td><td>没什么用的参数，我也不知道干嘛的</td><td></td></tr><tr><td>–junit-xml&#x3D;path</td><td>在给定的path路径下生成junit-xml风格的测试报告</td><td></td></tr><tr><td>–junit-prefix&#x3D;str</td><td>在junit-xml输出中的classnames添加前缀</td><td></td></tr><tr><td>pytest-warnings</td><td>-W  PYTHONWARNINGS, –pythonwarnings&#x3D;PYTHONWARNINGS</td><td>设置报告哪些warnings</td></tr><tr><td>–maxfail&#x3D;num</td><td>出现num个errors或者fails就退出测试</td><td></td></tr><tr><td>–strict-config</td><td>解析配置文件中pytest部分时，遇到warning就抛出error</td><td></td></tr><tr><td>–strict-markers, –strict</td><td>发现未知标记时，抛出error，</td><td></td></tr><tr><td>-c file</td><td>从指定配置文件加载配置，默认为pytes.ini</td><td></td></tr><tr><td>–continue-on-collection-errors</td><td>在收集用例时发生错误，也会继续执行用例</td><td></td></tr><tr><td>–rootdir&#x3D;ROOTDIR</td><td>tests根目录，相对路径</td><td></td></tr><tr><td>collection</td><td>–collect-only, –co</td><td>收集用例，但不执行</td></tr><tr><td>–pyargs</td><td>把所有参数解释为python包</td><td></td></tr><tr><td>–ignore&#x3D;path</td><td>忽略测试目录，使用英文逗号分割</td><td></td></tr><tr><td>–ignore-glob&#x3D;path</td><td>path匹配多个不需要收集的测试目录，使用英文逗号分割</td><td></td></tr><tr><td>–deselect&#x3D;nodeid_prefix</td><td>通过node  id prefix反选。可以多个，使用英文逗号分隔</td><td></td></tr><tr><td>–confcutdir&#x3D;dir</td><td>只加载相对于dir目录的conftest.py文件</td><td></td></tr><tr><td>–noconftest</td><td>不加载conftest.py文件</td><td></td></tr><tr><td>–keep-duplicates</td><td>收集重复的test文件，默认只会收集1item，加参数后会收集2items</td><td></td></tr><tr><td>–collect-in-virtualenv</td><td>收集本地虚拟环境目录的tests</td><td></td></tr><tr><td>–import-mode&#x3D;{prepend,append,importlib}</td><td>包导入模式，一般用不到，参考：<a href="https://www.osgeo.cn/pytest/pythonpath.html?highlight=import%20mode">https://www.osgeo.cn/pytest/pythonpath.html?highlight=import%20mode</a></td><td></td></tr><tr><td>–doctest-modules</td><td>文档测试，没啥用</td><td></td></tr><tr><td>–doctest-report&#x3D;{none,cdiff,ndiff,udiff,only_first_failure}</td><td>一样，也没啥用</td><td></td></tr><tr><td>–doctest-glob&#x3D;pat</td><td>还是没啥用</td><td></td></tr><tr><td>–doctest-ignore-import-errors</td><td>文档测试时忽略导包错误，继续没什么用</td><td></td></tr><tr><td>–doctest-continue-on-failure</td><td>文档测试时出现失败继续测试，依然没什么用</td><td></td></tr><tr><td>test session debugging and configuration</td><td>–basetemp&#x3D;dir</td><td>test  run的base临时目录（如果存在会先删除）</td></tr><tr><td>-V, –version</td><td>输出pytest版本</td><td></td></tr><tr><td>-h, –help</td><td>打印pytest帮助信息</td><td></td></tr><tr><td>-p name</td><td>加载插件，一般不会控制此参数</td><td></td></tr><tr><td>–trace-config</td><td>查看本地安装好的第三方插件</td><td></td></tr><tr><td>–debug</td><td>保存debug信息到’pytestdebug.log’文件</td><td></td></tr><tr><td>-o OVERRIDE_INI, –override-ini&#x3D;OVERRIDE_INI</td><td>覆盖ini文件配置</td><td></td></tr><tr><td>–assert&#x3D;MODE</td><td>断言模式，默认rewrite</td><td></td></tr><tr><td>–setup-only</td><td>只加载fixture，不执行测试用例</td><td></td></tr><tr><td>–setup-show</td><td>在执行测试用例时，打印fixture步骤</td><td></td></tr><tr><td>–setup-plan</td><td>展示哪些用例和fixture将要被执行</td><td></td></tr><tr><td>logging</td><td>–log-level&#x3D;LEVEL</td><td>日志等级，默认  WARNING （具体日志等级参考 logging 模块中的日志等级）</td></tr><tr><td>–log-format&#x3D;LOG_FORMAT</td><td>日志格式（具体日志格式参考  logging 模块中的日志格式）</td><td></td></tr><tr><td>–log-date-format&#x3D;LOG_DATE_FORMA</td><td>日志日期格式（具体日志格式参考  logging 模块中的日志格式）</td><td></td></tr><tr><td>–log-cli-level&#x3D;LOG_CLI_LEVEL</td><td>cli日志等级（具体日志等级参考  logging 模块中的日志等级）</td><td></td></tr><tr><td>–log-cli-format&#x3D;LOG_CLI_FORMAT</td><td>cli日志格式（具体日志格式参考  logging 模块中的日志格式）</td><td></td></tr><tr><td>–log-cli-date-format&#x3D;LOG_CLI_DATE_FORMAT</td><td>cli日志日期格式（具体日志格式参考  logging 模块中的日志格式）</td><td></td></tr><tr><td>–log-file&#x3D;LOG_FILE</td><td>日志文件路径</td><td></td></tr><tr><td>–log-file-level&#x3D;LOG_FILE_LEVE</td><td>日志文件中的日志等级</td><td></td></tr><tr><td>–log-file-format&#x3D;LOG_FILE_FORMAT</td><td>日志文件中的日志格式</td><td></td></tr><tr><td>–log-file-date-format&#x3D;LOG_FILE_DATE_FORMAT</td><td>日志文件中的日志时间格式</td><td></td></tr><tr><td>–log-auto-indent&#x3D;LOG_AUTO_INDENT</td><td>自动缩进传递给日志模块的多行消息。接受true  | on、false | off或整数</td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分类&lt;/th&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;general&lt;/td&gt;
&lt;td&gt;-k&lt;/td&gt;
&lt;td&gt;支持python的表达式，用于筛选指定标记&amp;#</summary>
      
    
    
    
    <category term="测试" scheme="https://linvaux.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="Pytest" scheme="https://linvaux.github.io/tags/Pytest/"/>
    
  </entry>
  
</feed>
